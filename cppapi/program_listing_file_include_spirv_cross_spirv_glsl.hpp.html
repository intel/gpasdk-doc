<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File spirv_glsl.hpp &mdash; IntelÂ® GPA Framework  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/gpa.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
     
    <script type="text/javascript">
        //configure tms    
        var wapLocalCode = 'us_en'; //dynamically set per localized site, see mapping table for values
        var wapSection = "gpa-sdk";
        //load tms
        (function() {
            var host = (window.document.location.protocol == 'http:') ? "http://www.intel.com" : "https://www.intel.com";
            var url = host+"/content/dam/www/global/wap/tms-loader.js"; //wap file url
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;  po.src = url;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
    </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

    <form action="https://software.intel.com/en-us/gpa" method="get" target="_blank">
        <button class="download-button" type="submit">Free Download</button>
    </form>
    

          
          
          <a href="../index.html">
            
              <img src="../_static/logo-classicblue-3000px.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../src/getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#layer-framework-primer">Layer Framework Primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#capture-a-stream">Capture a Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#play-back-stream">Play Back Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#stack-multiple-layers">Stack Multiple Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/guides.html">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/guides/extending_test_layer.html">Extending &quot;Helloworld&quot; Simple Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#layer-anatomy">Layer Anatomy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#api-call-routing">API Call Routing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/samples.html">Samples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/samples.html#build-samples">Build Samples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#windows">Windows*</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/samples.html#available-samples">Available Samples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#print-api-log">Print API Log</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#helloworld-simple-layer">'Helloworld' Simple Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#helloworld-generated-layer">'Helloworld' Generated Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#range-player">Range Player</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#buffer-extractor">Buffer Extractor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#texture-extraction">Texture Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#sampler-extractor">Sampler Extractor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#shader-extractor">Shader Extractor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#disable-call-in-range">Disable Call in Range</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#metrics-collection">Metrics Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#highlighting-experiment">Highlighting Experiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#pipeline-experiment">Pipeline Experiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#texture-replacement-experiments">Texture Replacement Experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#advanced-stream-playback">Advanced Stream Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#stream-filter">Stream Filter</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/reference.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-injector">gpa-injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-player">gpa-player</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-subcapture-recorder">gpa-subcapture-recorder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-info">gpa-stream-info</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-analyzer">gpa-stream-analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-cpp-generator">gpa-cpp-generator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-help">gpa-help</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-metrics-collector">gpa-metrics-collector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-system-info">gpa-system-info</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/layers.html">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#capture">capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#screenshot">screenshot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#hud-layer">hud-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#logging">logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#api-debug-layer">api-debug-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#device-override">device-override</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-resources-layer">dump-resources-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-state-layer">dump-state-layer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/python.html">Python Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html">C++ Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#page-hierarchy">Page Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#class-hierarchy">Class Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#file-hierarchy">File Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#full-api">Full API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#namespaces">Namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#classes-and-structs">Classes and Structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#unions">Unions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#variables">Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#defines">Defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#typedefs">Typedefs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/features.html">Features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#capture-and-playback">Capture and Playback</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#basic-capture-and-playback">Basic Capture and Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#keyframing-capture">Keyframing Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#deferred-capture">Deferred Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#range-repeat">Range Repeat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#subcapture">Subcapture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#stream-analysis">Stream Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metric-collection">Metric Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#experiments">Experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metadata-extraction">Metadata Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#resource-extraction">Resource Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-call-inspection">API Call Inspection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#layers">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#heads-up-display-hud-layer">Heads-Up Display(HUD) Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#screenshot-layer">Screenshot Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#logging-layer">Logging Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-debug-layer">Api Debug Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#device-override-layer">Device Override Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#custom-user-layers">Custom (User) Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/requirements.html">System Requirements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#hardware-requirements">Hardware Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#software-requirements">Software Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#supported-graphics-apis">Supported Graphics APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#dec-14-2023">2023.4 (Dec 14 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#new">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#changed">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#fixed">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#sept-21-2023">2023.3 (Sept 21 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id2">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id3">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id4">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2023">2023.2 (15 June 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id5">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id6">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id7">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2023">2023.1 (15 March 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id8">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id9">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id10">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2022">2022.4 (15 December 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id11">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id12">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id13">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#deprecated">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2022">2022.3 (15 September 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id14">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id15">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id16">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2022">2022.2 (30 June 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id17">New</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2022">2022.1 (16 March 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id18">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id19">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id20">Changed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2021">2021.4 (16 December 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id21">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id22">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id23">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2021">2021.3 (23 September 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id24">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id25">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id26">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2021">2021.2 (24 June 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id27">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id28">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id29">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2021">2021.1 (24 March 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id30">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id31">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id32">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#january-2021">2020.4.1 (21 January 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id33">NEW</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2020">2020.4 (14 December 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id34">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id35">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id36">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2020">2020.3 (24 September 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id37">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id38">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id39">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2020">2020.2 (25 June 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id40">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id43">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id44">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2020">2020.1 (26 March 2020)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2019">2019.4 (19 December 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2019">2019.3 (26 September 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2019">2019.2 (27 June 2019)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#known-issues-and-limitations">Known Issues and Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id2">2023.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id7">2023.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id10">2023.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id13">2023.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id16">2022.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id17">2022.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id18">2022.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id19">2022.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id20">2021.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id21">2021.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id22">2021.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id23">2020.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id24">2019.2</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/licenses.html">Legal Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/licenses.html#third-party-content">Third Party Content</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/disclaimer.html">Notices &amp; Disclaimers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">IntelÂ® GPA Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File spirv_glsl.hpp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-spirv-glsl-hpp">
<span id="program-listing-file-include-spirv-cross-spirv-glsl-hpp"></span><h1>Program Listing for File spirv_glsl.hpp<a class="headerlink" href="#program-listing-for-file-spirv-glsl-hpp" title="Permalink to this headline">ï</a></h1>
<p>â° <a class="reference internal" href="file_include_spirv_cross_spirv_glsl.hpp.html#file-include-spirv-cross-spirv-glsl-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">include\spirv_cross\spirv_glsl.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright 2015-2021 Arm Limited</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0 OR MIT</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * At your option, you may choose to accept this material under either:</span>
<span class="cm"> *  1. The Apache License, Version 2.0, found at &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;, or</span>
<span class="cm"> *  2. The MIT License, found at &lt;http://opensource.org/licenses/MIT&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef SPIRV_CROSS_GLSL_HPP</span>
<span class="cp">#define SPIRV_CROSS_GLSL_HPP</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;GLSL.std.450.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv_cross.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_set&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">SPIRV_CROSS_NAMESPACE</span>
<span class="p">{</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">PlsFormat</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">PlsNone</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="n">PlsR11FG11FB10F</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsR32F</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsRG16F</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsRGB10A2</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsRGBA8</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsRG16</span><span class="p">,</span>

<span class="w">    </span><span class="n">PlsRGBA8I</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsRG16I</span><span class="p">,</span>

<span class="w">    </span><span class="n">PlsRGB10A2UI</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsRGBA8UI</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsRG16UI</span><span class="p">,</span>
<span class="w">    </span><span class="n">PlsR32UI</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">PlsRemap</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="n">PlsFormat</span><span class="w"> </span><span class="n">format</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">AccessChainFlagBits</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ACCESS_CHAIN_INDEX_IS_LITERAL_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">ACCESS_CHAIN_CHAIN_ONLY_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">ACCESS_CHAIN_PTR_CHAIN_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">ACCESS_CHAIN_SKIP_REGISTER_EXPRESSION_READ_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">ACCESS_CHAIN_LITERAL_MSB_FORCE_ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">ACCESS_CHAIN_FLATTEN_ALL_MEMBERS_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="n">ACCESS_CHAIN_FORCE_COMPOSITE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">6</span>
<span class="p">};</span>
<span class="k">typedef</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">AccessChainFlags</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CompilerGLSL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">Compiler</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Options</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// The shading language version. Corresponds to #version $VALUE.</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">450</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Emit the OpenGL ES shading language instead of desktop OpenGL.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">es</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Debug option to always emit temporary variables for all expressions.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_temporary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Debug option, can be increased in an attempt to workaround SPIRV-Cross bugs temporarily.</span>
<span class="w">        </span><span class="c1">// If this limit has to be increased, it points to an implementation bug.</span>
<span class="w">        </span><span class="c1">// In certain scenarios, the maximum number of debug iterations may increase beyond this limit</span>
<span class="w">        </span><span class="c1">// as long as we can prove we&#39;re making certain kinds of forward progress.</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">force_recompile_max_debug_iterations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If true, Vulkan GLSL features are used instead of GL-compatible features.</span>
<span class="w">        </span><span class="c1">// Mostly useful for debugging SPIR-V files.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">vulkan_semantics</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If true, gl_PerVertex is explicitly redeclared in vertex, geometry and tessellation shaders.</span>
<span class="w">        </span><span class="c1">// The members of gl_PerVertex is determined by which built-ins are declared by the shader.</span>
<span class="w">        </span><span class="c1">// This option is ignored in ES versions, as redeclaration in ES is not required, and it depends on a different extension</span>
<span class="w">        </span><span class="c1">// (EXT_shader_io_blocks) which makes things a bit more fuzzy.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">separate_shader_objects</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Flattens multidimensional arrays, e.g. float foo[a][b][c] into single-dimensional arrays,</span>
<span class="w">        </span><span class="c1">// e.g. float foo[a * b * c].</span>
<span class="w">        </span><span class="c1">// This function does not change the actual SPIRType of any object.</span>
<span class="w">        </span><span class="c1">// Only the generated code, including declarations of interface variables are changed to be single array dimension.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">flatten_multidimensional_arrays</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// For older desktop GLSL targets than version 420, the</span>
<span class="w">        </span><span class="c1">// GL_ARB_shading_language_420pack extensions is used to be able to support</span>
<span class="w">        </span><span class="c1">// layout(binding) on UBOs and samplers.</span>
<span class="w">        </span><span class="c1">// If disabled on older targets, binding decorations will be stripped.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_420pack_extension</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// In non-Vulkan GLSL, emit push constant blocks as UBOs rather than plain uniforms.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">emit_push_constant_as_uniform_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Always emit uniform blocks as plain uniforms, regardless of the GLSL version, even when UBOs are supported.</span>
<span class="w">        </span><span class="c1">// Does not apply to shader storage or push constant blocks.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">emit_uniform_buffer_as_plain_uniforms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Emit OpLine directives if present in the module.</span>
<span class="w">        </span><span class="c1">// May not correspond exactly to original source, but should be a good approximation.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">emit_line_directives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// In cases where readonly/writeonly decoration are not used at all,</span>
<span class="w">        </span><span class="c1">// we try to deduce which qualifier(s) we should actually used, since actually emitting</span>
<span class="w">        </span><span class="c1">// read-write decoration is very rare, and older glslang/HLSL compilers tend to just emit readwrite as a matter of fact.</span>
<span class="w">        </span><span class="c1">// The default (true) is to enable automatic deduction for these cases, but if you trust the decorations set</span>
<span class="w">        </span><span class="c1">// by the SPIR-V, it&#39;s recommended to set this to false.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_storage_image_qualifier_deduction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// On some targets (WebGPU), uninitialized variables are banned.</span>
<span class="w">        </span><span class="c1">// If this is enabled, all variables (temporaries, Private, Function)</span>
<span class="w">        </span><span class="c1">// which would otherwise be uninitialized will now be initialized to 0 instead.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_zero_initialized_variables</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// In GLSL, force use of I/O block flattening, similar to</span>
<span class="w">        </span><span class="c1">// what happens on legacy GLSL targets for blocks and structs.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_flattened_io_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// For opcodes where we have to perform explicit additional nan checks, very ugly code is generated.</span>
<span class="w">        </span><span class="c1">// If we opt-in, ignore these requirements.</span>
<span class="w">        </span><span class="c1">// In opcodes like NClamp/NMin/NMax and FP compare, ignore NaN behavior.</span>
<span class="w">        </span><span class="c1">// Use FClamp/FMin/FMax semantics for clamps and lets implementation choose ordered or unordered</span>
<span class="w">        </span><span class="c1">// compares.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">relax_nan_checks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Loading row-major matrices from UBOs on older AMD Windows OpenGL drivers is problematic.</span>
<span class="w">        </span><span class="c1">// To load these types correctly, we must generate a wrapper. them in a dummy function which only purpose is to</span>
<span class="w">        </span><span class="c1">// ensure row_major decoration is actually respected.</span>
<span class="w">        </span><span class="c1">// This workaround may cause significant performance degeneration on some Android devices.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_row_major_load_workaround</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If non-zero, controls layout(num_views = N) in; in GL_OVR_multiview2.</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ovr_multiview_view_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="nc">Precision</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">DontCare</span><span class="p">,</span>
<span class="w">            </span><span class="n">Lowp</span><span class="p">,</span>
<span class="w">            </span><span class="n">Mediump</span><span class="p">,</span>
<span class="w">            </span><span class="n">Highp</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">VertexOptions</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// &quot;Vertex-like shader&quot; here is any shader stage that can write BuiltInPosition.</span>

<span class="w">            </span><span class="c1">// GLSL: In vertex-like shaders, rewrite [0, w] depth (Vulkan/D3D style) to [-w, w] depth (GL style).</span>
<span class="w">            </span><span class="c1">// MSL: In vertex-like shaders, rewrite [-w, w] depth (GL style) to [0, w] depth.</span>
<span class="w">            </span><span class="c1">// HLSL: In vertex-like shaders, rewrite [-w, w] depth (GL style) to [0, w] depth.</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">fixup_clipspace</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// In vertex-like shaders, inverts gl_Position.y or equivalent.</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">flip_vert_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// GLSL only, for HLSL version of this option, see CompilerHLSL.</span>
<span class="w">            </span><span class="c1">// If true, the backend will assume that InstanceIndex will need to apply</span>
<span class="w">            </span><span class="c1">// a base instance offset. Set to false if you know you will never use base instance</span>
<span class="w">            </span><span class="c1">// functionality as it might remove some internal uniforms.</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_nonzero_base_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">vertex</span><span class="p">;</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">FragmentOptions</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Add precision mediump float in ES targets when emitting GLES source.</span>
<span class="w">            </span><span class="c1">// Add precision highp int in ES targets when emitting GLES source.</span>
<span class="w">            </span><span class="n">Precision</span><span class="w"> </span><span class="n">default_float_precision</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mediump</span><span class="p">;</span>
<span class="w">            </span><span class="n">Precision</span><span class="w"> </span><span class="n">default_int_precision</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Highp</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">fragment</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remap_pixel_local_storage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PlsRemap</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PlsRemap</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputs</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">pls_inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">inputs</span><span class="p">);</span>
<span class="w">        </span><span class="n">pls_outputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">outputs</span><span class="p">);</span>
<span class="w">        </span><span class="n">remap_pls_variables</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Redirect a subpassInput reading from input_attachment_index to instead load its value from</span>
<span class="w">    </span><span class="c1">// the color attachment at location = color_location. Requires ESSL.</span>
<span class="w">    </span><span class="c1">// If coherent, uses GL_EXT_shader_framebuffer_fetch, if not, uses noncoherent variant.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remap_ext_framebuffer_fetch</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">input_attachment_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">color_location</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">coherent</span><span class="p">);</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spirv_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">Compiler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">spirv_</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">init</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ir_</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">word_count</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">Compiler</span><span class="p">(</span><span class="n">ir_</span><span class="p">,</span><span class="w"> </span><span class="n">word_count</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">init</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ir_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">Compiler</span><span class="p">(</span><span class="n">ir_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">init</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">ir_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">Compiler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ir_</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">init</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Options</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_common_options</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">options</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_common_options</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Options</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opts</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">compile</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns the current string held in the conversion buffer. Useful for</span>
<span class="w">    </span><span class="c1">// capturing what has been converted so far when compile() throws an error.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_partial_source</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Adds a line to be added right after #version in GLSL backend.</span>
<span class="w">    </span><span class="c1">// This is useful for enabling custom extensions which are outside the scope of SPIRV-Cross.</span>
<span class="w">    </span><span class="c1">// This can be combined with variable remapping.</span>
<span class="w">    </span><span class="c1">// A new-line will be added.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// While add_header_line() is a more generic way of adding arbitrary text to the header</span>
<span class="w">    </span><span class="c1">// of a GLSL file, require_extension() should be used when adding extensions since it will</span>
<span class="w">    </span><span class="c1">// avoid creating collisions with SPIRV-Cross generated extensions.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Code added via add_header_line() is typically backend-specific.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_header_line</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Adds an extension which is required to run this shader, e.g.</span>
<span class="w">    </span><span class="c1">// require_extension(&quot;GL_KHR_my_extension&quot;);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">require_extension</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ext</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Returns the list of required extensions. After compilation this will contains any other</span>
<span class="w">    </span><span class="c1">// extensions that the compiler used automatically, in addition to the user specified ones.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_required_extensions</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Legacy GLSL compatibility method.</span>
<span class="w">    </span><span class="c1">// Takes a uniform or push constant variable and flattens it into a (i|u)vec4 array[N]; array instead.</span>
<span class="w">    </span><span class="c1">// For this to work, all types in the block must be the same basic type, e.g. mixing vec2 and vec4 is fine, but</span>
<span class="w">    </span><span class="c1">// mixing int and float is not.</span>
<span class="w">    </span><span class="c1">// The name of the uniform array will be the same as the interface block name.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flatten_buffer_block</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// After compilation, query if a variable ID was used as a depth resource.</span>
<span class="w">    </span><span class="c1">// This is meaningful for MSL since descriptor types depend on this knowledge.</span>
<span class="w">    </span><span class="c1">// Cases which return true:</span>
<span class="w">    </span><span class="c1">// - Images which are declared with depth = 1 image type.</span>
<span class="w">    </span><span class="c1">// - Samplers which are statically used at least once with Dref opcodes.</span>
<span class="w">    </span><span class="c1">// - Images which are statically used at least once with Dref opcodes.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">variable_is_depth_or_compare</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If a shader output is active in this stage, but inactive in a subsequent stage,</span>
<span class="w">    </span><span class="c1">// this can be signalled here. This can be used to work around certain cross-stage matching problems</span>
<span class="w">    </span><span class="c1">// which plagues MSL and HLSL in certain scenarios.</span>
<span class="w">    </span><span class="c1">// An output which matches one of these will not be emitted in stage output interfaces, but rather treated as a private</span>
<span class="w">    </span><span class="c1">// variable.</span>
<span class="w">    </span><span class="c1">// This option is only meaningful for MSL and HLSL, since GLSL matches by location directly.</span>
<span class="w">    </span><span class="c1">// Masking builtins only takes effect if the builtin in question is part of the stage output interface.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mask_stage_output_by_location</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">component</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mask_stage_output_by_builtin</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">);</span>

<span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ShaderSubgroupSupportHelper</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// lower enum value = greater priority</span>
<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="nc">Candidate</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">KHR_shader_subgroup_ballot</span><span class="p">,</span>
<span class="w">            </span><span class="n">KHR_shader_subgroup_basic</span><span class="p">,</span>
<span class="w">            </span><span class="n">KHR_shader_subgroup_vote</span><span class="p">,</span>
<span class="w">            </span><span class="n">KHR_shader_subgroup_arithmetic</span><span class="p">,</span>
<span class="w">            </span><span class="n">NV_gpu_shader_5</span><span class="p">,</span>
<span class="w">            </span><span class="n">NV_shader_thread_group</span><span class="p">,</span>
<span class="w">            </span><span class="n">NV_shader_thread_shuffle</span><span class="p">,</span>
<span class="w">            </span><span class="n">ARB_shader_ballot</span><span class="p">,</span>
<span class="w">            </span><span class="n">ARB_shader_group_vote</span><span class="p">,</span>
<span class="w">            </span><span class="n">AMD_gcn_shader</span><span class="p">,</span>

<span class="w">            </span><span class="n">CandidateCount</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">get_extension_name</span><span class="p">(</span><span class="n">Candidate</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_extra_required_extension_names</span><span class="p">(</span><span class="n">Candidate</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">get_extra_required_extension_predicate</span><span class="p">(</span><span class="n">Candidate</span><span class="w"> </span><span class="n">c</span><span class="p">);</span>

<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="nc">Feature</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">SubgroupMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupInvocationID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">            </span><span class="n">NumSubgroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupBroadcast_First</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupBallotFindLSB_MSB</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupAll_Any_AllEqualBool</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupAllEqualT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupElect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupBarrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupMemBarrier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">11</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupBallot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupInverseBallot_InclBitCount_ExclBitCout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupBallotBitExtract</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">14</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupBallotBitCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">15</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticIAddReduce</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticIAddExclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">17</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticIAddInclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">18</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticFAddReduce</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">19</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticFAddExclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticFAddInclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticIMulReduce</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">22</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticIMulExclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticIMulInclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">24</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticFMulReduce</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticFMulExclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">26</span><span class="p">,</span>
<span class="w">            </span><span class="n">SubgroupArithmeticFMulInclusiveScan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">27</span><span class="p">,</span>
<span class="w">            </span><span class="n">FeatureCount</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="n">FeatureMask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">;</span>
<span class="w">        </span><span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FeatureMask</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">8u</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">FeatureCount</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Mask type needs more bits.&quot;</span><span class="p">);</span>

<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="n">CandidateVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Candidate</span><span class="p">,</span><span class="w"> </span><span class="n">CandidateCount</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="n">FeatureVector</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Feature</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">FeatureVector</span><span class="w"> </span><span class="nf">get_feature_dependencies</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">);</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">FeatureMask</span><span class="w"> </span><span class="nf">get_feature_dependency_mask</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">);</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">can_feature_be_implemented_without_extensions</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">);</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">Candidate</span><span class="w"> </span><span class="nf">get_KHR_extension_for_feature</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">);</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">Result</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Result</span><span class="p">();</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">weights</span><span class="p">[</span><span class="n">CandidateCount</span><span class="p">];</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">request_feature</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_feature_requested</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="n">Result</span><span class="w"> </span><span class="nf">resolve</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">CandidateVector</span><span class="w"> </span><span class="nf">get_candidates_for_feature</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">ft</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Result</span><span class="w"> </span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">CandidateVector</span><span class="w"> </span><span class="n">get_candidates_for_feature</span><span class="p">(</span><span class="n">Feature</span><span class="w"> </span><span class="n">ft</span><span class="p">);</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">FeatureMask</span><span class="w"> </span><span class="nf">build_mask</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Feature</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">features</span><span class="p">);</span>
<span class="w">        </span><span class="n">FeatureMask</span><span class="w"> </span><span class="n">feature_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// TODO remove this function when all subgroup ops are supported (or make it always return true)</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_supported_subgroup_op_in_opengl</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">iteration_count</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_function</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">return_flags</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">has_extension</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ext</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">require_extension_internal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ext</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Virtualize methods which need to be overridden by subclass targets like C++ and such.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_function_prototype</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">return_flags</span><span class="p">);</span>

<span class="w">    </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">*</span><span class="n">current_emitting_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">current_emitting_switch_stack</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">current_emitting_switch_fallthrough</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_instruction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instr</span><span class="p">);</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TemporaryCopy</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst_id</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">src_id</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">TemporaryCopy</span><span class="w"> </span><span class="nf">handle_instruction_precision</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_block_instructions</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_block_instructions_with_masked_debug</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// For relax_nan_checks.</span>
<span class="w">    </span><span class="n">GLSLstd450</span><span class="w"> </span><span class="nf">get_remapped_glsl_op</span><span class="p">(</span><span class="n">GLSLstd450</span><span class="w"> </span><span class="n">std450_op</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="nf">get_remapped_spirv_op</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_glsl_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
<span class="w">                              </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_spv_amd_shader_ballot_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span>
<span class="w">                                               </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_spv_amd_shader_explicit_vertex_parameter_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span>
<span class="w">                                                                  </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_spv_amd_shader_trinary_minmax_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span>
<span class="w">                                                       </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_spv_amd_gcn_shader_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
<span class="w">                                            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_header</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_line_directive</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">file_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">line_literal</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_workgroup_size</span><span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arguments</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SpecializationConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span>
<span class="w">                              </span><span class="k">const</span><span class="w"> </span><span class="n">SpecializationConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SpecializationConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">z</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">request_subgroup_feature</span><span class="p">(</span><span class="n">ShaderSubgroupSupportHelper</span><span class="o">::</span><span class="n">Feature</span><span class="w"> </span><span class="n">feature</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_sampled_image_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">image_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">samp_id</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_texture_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">sparse</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_texture_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">sparse</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="n">forward</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inherited_expressions</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_subgroup_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">type_to_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">builtin_to_glsl</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">emit_struct_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">member_type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qualifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_struct_padding_target</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">image_type_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">constant_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">bool</span><span class="w"> </span><span class="n">inside_block_like_struct_scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">bool</span><span class="w"> </span><span class="n">inside_struct_scope</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">constant_op_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstantOp</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cop</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">constant_expression_vector</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vector</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_fixup</span><span class="p">();</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">variable_decl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">variable_decl_is_remapped_storage</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_func_call_arg</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="o">::</span><span class="n">Parameter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TextureFunctionBaseArguments</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// GCC 4.8 workarounds, it doesn&#39;t understand &#39;{}&#39; constructor here, use explicit default constructor.</span>
<span class="w">        </span><span class="n">TextureFunctionBaseArguments</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">        </span><span class="n">VariableID</span><span class="w"> </span><span class="n">img</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">*</span><span class="n">imgtype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_fetch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">is_gather</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">is_proj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TextureFunctionNameArguments</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// GCC 4.8 workarounds, it doesn&#39;t understand &#39;{}&#39; constructor here, use explicit default constructor.</span>
<span class="w">        </span><span class="n">TextureFunctionNameArguments</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">        </span><span class="n">TextureFunctionBaseArguments</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_array_offsets</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">has_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">has_grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_dref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">is_sparse_feedback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="n">has_min_lod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_function_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TextureFunctionNameArguments</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TextureFunctionArguments</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// GCC 4.8 workarounds, it doesn&#39;t understand &#39;{}&#39; constructor here, use explicit default constructor.</span>
<span class="w">        </span><span class="n">TextureFunctionArguments</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">        </span><span class="n">TextureFunctionBaseArguments</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">coord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">coord_components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">dref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">grad_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">grad_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">lod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">sparse_texel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">min_lod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">nonuniform_expression</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_function_args</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TextureFunctionArguments</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="n">p_forward</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_sparse_feedback_temporaries</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">feedback_id</span><span class="p">,</span>
<span class="w">                                          </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">texel_id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_sparse_feedback_texel_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_buffer_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_push_constant_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_uniform</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">unpack_expression_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">expr_str</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_type_id</span><span class="p">,</span>
<span class="w">                                               </span><span class="kt">bool</span><span class="w"> </span><span class="n">packed_type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">row_major</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">builtin_translates_to_nonarray</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_user_type_structured</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_copy_logical_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lhs_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lhs_type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rhs_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rhs_type_id</span><span class="p">,</span>
<span class="w">                                </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">chain</span><span class="p">);</span>

<span class="w">    </span><span class="n">StringStream</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">;</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">statement_inner</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">buffer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="w">        </span><span class="n">statement_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">statement_inner</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">buffer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="w">        </span><span class="n">statement_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">statement_inner</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">statement</span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_forcing_recompilation</span><span class="p">())</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Do not bother emitting code while force_recompile is active.</span>
<span class="w">            </span><span class="c1">// We will compile again.</span>
<span class="w">            </span><span class="n">statement_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">redirect_statement</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">redirect_statement</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...));</span>
<span class="w">            </span><span class="n">statement_count</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="n">buffer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;    &quot;</span><span class="p">;</span>
<span class="w">            </span><span class="n">statement_inner</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...);</span>
<span class="w">            </span><span class="n">buffer</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">statement_no_indent</span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">old_indent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">indent</span><span class="p">;</span>
<span class="w">        </span><span class="n">indent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">statement</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...);</span>
<span class="w">        </span><span class="n">indent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_indent</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Used for implementing continue blocks where</span>
<span class="w">    </span><span class="c1">// we want to obtain a list of statements we can merge</span>
<span class="w">    </span><span class="c1">// on a single line separated by comma.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">redirect_statement</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">*</span><span class="n">current_continue_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">block_temporary_hoisting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">block_debug_directives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">begin_scope</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">end_scope</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">end_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">trailer</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">end_scope_decl</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">end_scope_decl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">decl</span><span class="p">);</span>

<span class="w">    </span><span class="n">Options</span><span class="w"> </span><span class="n">options</span><span class="p">;</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">type_to_array_glsl</span><span class="p">(</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span><span class="w"> </span><span class="c1">// Allow Metal to use the array&lt;T&gt; template to make arrays a value type</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_array_size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">to_array_size_literal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">to_array_size_literal</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">variable_decl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable</span><span class="p">);</span><span class="w"> </span><span class="c1">// Threadgroup arrays can&#39;t have a wrapper type</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">variable_decl_function_local</span><span class="p">(</span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_local_variable_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_resource_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_member_name</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_function_overload</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_non_native_row_major_matrix</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">member_is_non_native_row_major_matrix</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">member_is_remapped_physical_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">member_is_packed_physical_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">convert_row_major_matrix</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">exp_str</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">exp_type</span><span class="p">,</span>
<span class="w">                                                 </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_packed</span><span class="p">,</span>
<span class="w">                                                 </span><span class="kt">bool</span><span class="w"> </span><span class="n">relaxed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_variable_names</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">resource_names</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">block_input_names</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">block_output_names</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">block_ubo_names</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">block_ssbo_names</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">block_names</span><span class="p">;</span><span class="w"> </span><span class="c1">// A union of all block_*_names.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">function_overloads</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">preserved_aliases</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">preserve_alias_on_reset</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">reset_name_caches</span><span class="p">();</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">processing_entry_point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Can be overriden by subclass backends for trivial things which</span>
<span class="w">    </span><span class="c1">// shouldn&#39;t need polymorphism.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">BackendVariations</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">discard_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;discard&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">demote_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;demote&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">null_pointer_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">float_literal_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">double_literal_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">uint32_t_literal_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">long_long_literal_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">basic_int_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;int&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">basic_uint_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;uint&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">basic_int8_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;int8_t&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">basic_uint8_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;uint8_t&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">basic_int16_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;int16_t&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">basic_uint16_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;uint16_t&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">int16_t_literal_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;s&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">uint16_t_literal_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;us&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">nonuniform_qualifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;nonuniformEXT&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">boolean_mix_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;mix&quot;</span><span class="p">;</span>
<span class="w">        </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">boolean_in_struct_remapped_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Boolean</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">swizzle_is_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">shared_is_implied</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">unsized_array_supported</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicit_struct_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_initializer_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_typed_initializer_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">can_declare_struct_inline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">can_declare_arrays_inline</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">native_row_major_matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_constructor_splatting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">allow_precision_qualifiers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">can_swizzle_scalar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_gl_in_out_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_merged_mesh_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">can_return_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">allow_truncated_access_chain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">supports_extensions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">supports_empty_struct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">array_is_value_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">array_is_value_type_in_buffer_blocks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">comparison_image_samples_scalar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">native_pointers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_small_type_sampling_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_case_fallthrough</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_array_constructor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_row_major_load_workaround</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_pointer_to_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_precise_qualifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_64bit_switch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">workgroup_size_is_hidden</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_relaxed_precision_analysis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">implicit_c_integer_promotion_rules</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">backend</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_struct</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_resources</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_extension_workarounds</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_subgroup_arithmetic_workaround</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">GroupOperation</span><span class="w"> </span><span class="n">group_op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_polyfills</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">polyfills</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">relaxed</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_buffer_block_native</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_buffer_reference_block</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">forward_declaration</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_buffer_block_legacy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_buffer_block_flattened</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fixup_implicit_builtin_block_names</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_declared_builtin_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">should_force_emit_builtin_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_push_constant_block_vulkan</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_push_constant_block_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_interface_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_flattened_io_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">qual</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_flattened_io_block_struct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">basename</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">qual</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_flattened_io_block_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">basename</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">qual</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_block_chain</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_hoisted_temporaries</span><span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TypeID</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">temporaries</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">constant_value_macro_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="nf">get_constant_mapping_to_workgroup_component</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">constant</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_constant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">constant</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_specialization_constant_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstantOp</span><span class="w"> </span><span class="o">&amp;</span><span class="n">constant</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">emit_continue_block</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">continue_block</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">follow_true_block</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">follow_false_block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">attempt_emit_loop_header</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="o">::</span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">branch</span><span class="p">(</span><span class="n">BlockID</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">BlockID</span><span class="w"> </span><span class="n">to</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">branch_to_continue</span><span class="p">(</span><span class="n">BlockID</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">BlockID</span><span class="w"> </span><span class="n">to</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">branch</span><span class="p">(</span><span class="n">BlockID</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cond</span><span class="p">,</span><span class="w"> </span><span class="n">BlockID</span><span class="w"> </span><span class="n">true_block</span><span class="p">,</span><span class="w"> </span><span class="n">BlockID</span><span class="w"> </span><span class="n">false_block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_phi</span><span class="p">(</span><span class="n">BlockID</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">BlockID</span><span class="w"> </span><span class="n">to</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_variable_declaration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_undeclared_variables</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_variable_temporary_copies</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">should_dereference</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">should_forward</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">should_suppress_usage_tracking</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_mix_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lerp</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_nminmax_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="n">GLSLstd450</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_emulated_ahyper_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="n">GLSLstd450</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">to_trivial_mix_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lerp</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_quaternary_func_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op2</span><span class="p">,</span>
<span class="w">                                 </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op3</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_trinary_func_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op2</span><span class="p">,</span>
<span class="w">                              </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_binary_func_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_atomic_func_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_atomic_func_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_unary_func_op_cast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">expected_result_type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_binary_func_op_cast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span>
<span class="w">                                  </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">skip_cast_if_equal_type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_binary_func_op_cast_clustered</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span>
<span class="w">                                            </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_trinary_func_op_cast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op2</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_trinary_func_op_bitextract</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span>
<span class="w">                                         </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">expected_result_type</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type0</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type1</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type2</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_bitfield_insert_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op2</span><span class="p">,</span>
<span class="w">                                 </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op3</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">offset_count_type</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_unary_func_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_unrolled_unary_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">operand</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_binary_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_unrolled_binary_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span>
<span class="w">                                 </span><span class="kt">bool</span><span class="w"> </span><span class="n">negate</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">expected_type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_binary_op_cast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span>
<span class="w">                             </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">input_type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">skip_cast_if_equal_type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">implicit_integer_promotion</span><span class="p">);</span>

<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="nf">binary_op_bitcast_helper</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cast_op0</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cast_op1</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input_type</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">skip_cast_if_equal_type</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emit_complex_bitcast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_ternary_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">select</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">true_value</span><span class="p">,</span>
<span class="w">                                      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">false_value</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_unary_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_unary_op_cast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_mesh_tasks</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">expression_is_forwarded</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">expression_suppresses_usage_tracking</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">expression_read_implies_multiple_reads</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRExpression</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">emit_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">forward_rhs</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">bool</span><span class="w"> </span><span class="n">suppress_usage_tracking</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">access_chain_internal_append_index</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">AccessChainFlags</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">&amp;</span><span class="n">access_chain_is_arrayed</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">access_chain_internal</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">AccessChainFlags</span><span class="w"> </span><span class="n">flags</span><span class="p">,</span>
<span class="w">                                      </span><span class="n">AccessChainMeta</span><span class="w"> </span><span class="o">*</span><span class="n">meta</span><span class="p">);</span>

<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="nf">get_expression_effective_storage_class</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">access_chain_needs_stage_io_builtin_translation</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_physical_type_cast</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_type</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">prepare_access_chain_for_scalar_access</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                                        </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_packed</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">access_chain</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">target_type</span><span class="p">,</span>
<span class="w">                             </span><span class="n">AccessChainMeta</span><span class="w"> </span><span class="o">*</span><span class="n">meta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ptr_chain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">flattened_access_chain</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">                                       </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">target_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">matrix_stride</span><span class="p">,</span>
<span class="w">                                       </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">array_stride</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_transpose</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">flattened_access_chain_struct</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">                                              </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">target_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">flattened_access_chain_matrix</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">                                              </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">target_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">matrix_stride</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_transpose</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">flattened_access_chain_vector</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span>
<span class="w">                                              </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">target_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">matrix_stride</span><span class="p">,</span>
<span class="w">                                              </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_transpose</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flattened_access_chain_offset</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">basetype</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">indices</span><span class="p">,</span>
<span class="w">                                                                   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span>
<span class="w">                                                                   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">word_stride</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="n">need_transpose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">                                                                   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">matrix_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">                                                                   </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">array_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span>
<span class="w">                                                                   </span><span class="kt">bool</span><span class="w"> </span><span class="n">ptr_chain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">index_to_swizzle</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">remap_swizzle</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">input_components</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">declare_temporary</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_uninitialized_temporary</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">SPIRExpression</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">emit_uninitialized_temporary_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">append_global_func_args</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arglist</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_non_uniform_aware_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_composite_constructor_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parent_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">block_like_type</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_rerolled_array_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parent_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_enclosed_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_unpacked_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_unpacked_row_major_matrix_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_enclosed_unpacked_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_dereferenced_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_pointer_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_enclosed_pointer_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_extract_component_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_extract_constant_composite_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span>
<span class="w">                                                         </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">chain</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_enclose_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">enclose_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">dereference_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expression_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">address_of_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">strip_enclosed_expression</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_member_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_member_reference</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ptr_chain_is_resolved</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_multi_member_reference</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">type_to_glsl_constructor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">argument_decl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="o">::</span><span class="n">Parameter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_qualifiers_glsl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fixup_io_block_patch_primitive_qualifiers</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_output_variable_initializer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_precision_qualifiers_glsl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">to_storage_qualifiers_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">flags_to_qualifiers_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">format_to_glsl</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ImageFormat</span><span class="w"> </span><span class="n">format</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">layout_for_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_interpolation_qualifiers</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">layout_for_variable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_combined_image_sampler</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">image_id</span><span class="p">,</span><span class="w"> </span><span class="n">VariableID</span><span class="w"> </span><span class="n">samp_id</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">skip_argument</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emit_array_copy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lhs_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rhs_id</span><span class="p">,</span>
<span class="w">                                 </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">lhs_storage</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">rhs_storage</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_block_hints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_initializer_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_zero_initialized_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_can_zero_initialize</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">buffer_is_packing_standard</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">BufferPackingStandard</span><span class="w"> </span><span class="n">packing</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">failed_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">start_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">end_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">0u</span><span class="p">));</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">buffer_to_packing_standard</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_std430_without_scalar_layout</span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_to_packed_base_size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">BufferPackingStandard</span><span class="w"> </span><span class="n">packing</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_to_packed_alignment</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">BufferPackingStandard</span><span class="w"> </span><span class="n">packing</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_to_packed_array_stride</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">BufferPackingStandard</span><span class="w"> </span><span class="n">packing</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_to_packed_size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span><span class="w"> </span><span class="n">BufferPackingStandard</span><span class="w"> </span><span class="n">packing</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_to_location_count</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bitcast_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bitcast_glsl_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argument_type</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bitcast_expression</span><span class="p">(</span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">target_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bitcast_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">target_type</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">expr_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">build_composite_combiner</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">elems</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">remove_duplicate_swizzle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">remove_unity_swizzle</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Can modify flags to remote readonly/writeonly if image type</span>
<span class="w">    </span><span class="c1">// and force recompile.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">check_atomic_image</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">replace_illegal_names</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">replace_illegal_names</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">keywords</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_entry_point_declarations</span><span class="p">();</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">replace_fragment_output</span><span class="p">(</span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">replace_fragment_outputs</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">legacy_tex_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">imgtype</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">forward_relaxed_precision</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_precision_requirements</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="n">Options</span><span class="o">::</span><span class="n">Precision</span><span class="w"> </span><span class="nf">analyze_expression_precision</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">indent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">emitted_functions</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Ensure that we declare phi-variable copies even if the original declaration isn&#39;t deferred</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flushed_phi_variables</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flattened_buffer_blocks</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">flattened_structs</span><span class="p">;</span>

<span class="w">    </span><span class="n">ShaderSubgroupSupportHelper</span><span class="w"> </span><span class="n">shader_subgroup_supporter</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">load_flattened_struct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">basename</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_flattened_struct_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">basename</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">store_flattened_struct</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lhs_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">store_flattened_struct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">basename</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">indices</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_flattened_access_chain_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Usage tracking. If a temporary is used more than once, use the temporary instead to</span>
<span class="w">    </span><span class="c1">// avoid AST explosion when SPIRV is generated with pure SSA and doesn&#39;t write stuff to variables.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">expression_usage_counts</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">track_expression_read</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">forced_extensions</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">header_lines</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Used when expressions emit extra opcodes with their own unique IDs,</span>
<span class="w">    </span><span class="c1">// and we need to reuse the IDs across recompilation loops.</span>
<span class="w">    </span><span class="c1">// Currently used by NMin/Max/Clamp implementations.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">extra_sub_expressions</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">TypeID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">workaround_ubo_load_overload_types</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">request_workaround_wrapper_overload</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">rewrite_load_for_wrapped_row_major</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="n">TypeID</span><span class="w"> </span><span class="n">loaded_type</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">statement_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_legacy</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">es</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">300</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">options</span><span class="p">.</span><span class="n">es</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">130</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_legacy_es</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">es</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">300</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_legacy_desktop</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">options</span><span class="p">.</span><span class="n">es</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">options</span><span class="p">.</span><span class="n">version</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">130</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Polyfill</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint32_t</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">PolyfillTranspose2x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillTranspose3x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillTranspose4x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillDeterminant2x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillDeterminant3x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillDeterminant4x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillMatrixInverse2x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillMatrixInverse3x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">        </span><span class="n">PolyfillMatrixInverse4x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">required_polyfills</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">required_polyfills_relaxed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">require_polyfill</span><span class="p">(</span><span class="n">Polyfill</span><span class="w"> </span><span class="n">polyfill</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">relaxed</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ray_tracing_is_khr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">barycentric_is_nv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">ray_tracing_khr_fixup_locations</span><span class="p">();</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">args_will_forward</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_args</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">pure</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_call_out_argument</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_impure_function_call</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_control_dependent_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">expr</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// GL_EXT_shader_pixel_local_storage support.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PlsRemap</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pls_inputs</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PlsRemap</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pls_outputs</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">pls_decl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">PlsRemap</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">to_pls_qualifiers_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_pls</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remap_pls_variables</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// GL_EXT_shader_framebuffer_fetch support.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">subpass_to_framebuffer_fetch_attachment</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">inout_color_attachments</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">location_is_framebuffer_fetch</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">location_is_non_coherent_framebuffer_fetch</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">subpass_input_is_framebuffer_fetch</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_inout_fragment_outputs_copy_to_subpass_inputs</span><span class="p">();</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">*</span><span class="nf">find_subpass_input_by_attachment_index</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">*</span><span class="nf">find_color_output_by_location</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// A variant which takes two sets of name. The secondary is only used to verify there are no collisions,</span>
<span class="w">    </span><span class="c1">// but the set is not updated when we have found a new name.</span>
<span class="w">    </span><span class="c1">// Used primarily when adding block interface names.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_variable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variables_primary</span><span class="p">,</span>
<span class="w">                      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variables_secondary</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_function_call_constraints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">handle_invalid_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">force_temporary_and_recompile</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">find_static_extensions</span><span class="p">();</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">consume_temporary_in_precision_context</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">Options</span><span class="o">::</span><span class="n">Precision</span><span class="w"> </span><span class="n">precision</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">temporary_to_mirror_precision_alias</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">composite_insert_overwritten</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">block_composite_insert_overwrite</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">emit_for_loop_initializers</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_while_loop_initializers</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">for_loop_initializers_are_same_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">optimize_read_modify_write</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rhs</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fixup_image_load_store_access</span><span class="p">();</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_empty</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">can_use_io_location</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">*</span><span class="nf">get_next_instruction_in_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instr</span><span class="p">);</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">mask_relevant_memory_semantics</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">semantics</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">convert_half_to_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">convert_float_to_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">convert_double_to_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">convert_separate_image_to_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Builtins in GLSL are always specific signedness, but the SPIR-V can declare them</span>
<span class="w">    </span><span class="c1">// as either unsigned or signed.</span>
<span class="w">    </span><span class="c1">// Sometimes we will need to automatically perform casts on load and store to make this work.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">cast_to_variable_store</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">target_id</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr_type</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">cast_from_variable_load</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source_id</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr_type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unroll_array_from_complex_load</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">target_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source_id</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">unroll_array_to_complex_store</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">target_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source_id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">convert_non_uniform_expression</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ptr_id</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">handle_store_to_invariant_variable</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">store_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value_id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">disallow_forwarding_in_expression_chain</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRExpression</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">expression_is_constant_null</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">expression_is_non_value_type_array</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_store_statement</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lhs_expression</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rhs_expression</span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_integer_width_for_instruction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_integer_width_for_glsl_instruction</span><span class="p">(</span><span class="n">GLSLstd450</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">arguments</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">variable_is_lut</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">current_locale_radix_character</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fixup_type_alias</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">reorder_type_alias</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fixup_anonymous_struct_names</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fixup_anonymous_struct_names</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">visited</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">vector_swizzle</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">vecsize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_stage_output_location_masked</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">component</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_stage_output_builtin_masked</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_stage_output_variable_masked</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_stage_output_block_member_masked</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">strip_array</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_per_primitive_variable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_accumulated_member_location</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">strip_array</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_member_location</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">strip_array</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">LocationComponentPair</span><span class="p">,</span><span class="w"> </span><span class="n">InternalHasher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">masked_output_locations</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">masked_output_builtins</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">init</span><span class="p">();</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ConstantID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_composite_constant_ids</span><span class="p">(</span><span class="n">ConstantID</span><span class="w"> </span><span class="n">const_id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fill_composite_constant</span><span class="p">(</span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">constant</span><span class="p">,</span><span class="w"> </span><span class="n">TypeID</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ConstantID</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">initializers</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_composite_constant</span><span class="p">(</span><span class="n">ConstantID</span><span class="w"> </span><span class="n">const_id</span><span class="p">,</span><span class="w"> </span><span class="n">TypeID</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ConstantID</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">initializers</span><span class="p">);</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="nf">get_composite_member_type</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">member_idx</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ConstantID</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">const_composite_insert_ids</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace SPIRV_CROSS_NAMESPACE</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 - 2023 Intel Corporation.
This software and the related documents are Intel copyrighted materials, and your
use of them is governed by the express license under which they were provided to
you (License). Unless the License provides otherwise, you may not use, modify, copy,
publish, distribute, disclose or transmit this software or the related documents
without Intel&#39;s prior written permission.
This software and the related documents are provided as is, with no express or implied
warranties, other than those that are expressly stated in the License..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>