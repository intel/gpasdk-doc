<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File spirv_common.hpp &mdash; Intel® GPA Framework  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/gpa.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
     
    <script type="text/javascript">
        //configure tms    
        var wapLocalCode = 'us_en'; //dynamically set per localized site, see mapping table for values
        var wapSection = "gpa-sdk";
        //load tms
        (function() {
            var host = (window.document.location.protocol == 'http:') ? "http://www.intel.com" : "https://www.intel.com";
            var url = host+"/content/dam/www/global/wap/tms-loader.js"; //wap file url
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;  po.src = url;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
    </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

    <form action="https://software.intel.com/en-us/gpa" method="get" target="_blank">
        <button class="download-button" type="submit">Free Download</button>
    </form>
    

          
          
          <a href="../index.html">
            
              <img src="../_static/logo-classicblue-3000px.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../src/getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#layer-framework-primer">Layer Framework Primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#capture-a-stream">Capture a Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#play-back-stream">Play Back Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#stack-multiple-layers">Stack Multiple Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/guides.html">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/guides/extending_test_layer.html">Extending &quot;Helloworld&quot; Simple Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#layer-anatomy">Layer Anatomy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#api-call-routing">API Call Routing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/guides/logging_layer_filters.html">Logging Layer Filters</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/logging_layer_filters.html#usage">Usage</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/reference.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-injector">gpa-injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-player">gpa-player</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-subcapture-recorder">gpa-subcapture-recorder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-info">gpa-stream-info</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-analyzer">gpa-stream-analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-cpp-generator">gpa-cpp-generator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-help">gpa-help</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-metrics-collector">gpa-metrics-collector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-system-info">gpa-system-info</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/layers.html">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#capture">capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#screenshot">screenshot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#hud-layer">hud-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#logging">logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#api-debug-layer">api-debug-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#device-override">device-override</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-resources-layer">dump-resources-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-state-layer">dump-state-layer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/python.html">Python Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html">C++ Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#page-hierarchy">Page Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#class-hierarchy">Class Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#file-hierarchy">File Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#full-api">Full API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#namespaces">Namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#classes-and-structs">Classes and Structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#unions">Unions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#variables">Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#defines">Defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#typedefs">Typedefs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/features.html">Features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#capture-and-playback">Capture and Playback</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#basic-capture-and-playback">Basic Capture and Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#deferred-capture">Deferred Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#range-repeat">Range Repeat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#subcapture">Subcapture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#stream-analysis">Stream Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metric-collection">Metric Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#experiments">Experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metadata-extraction">Metadata Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#resource-extraction">Resource Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-call-inspection">API Call Inspection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#layers">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#heads-up-display-hud-layer">Heads-Up Display(HUD) Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#screenshot-layer">Screenshot Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#logging-layer">Logging Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-debug-layer">Api Debug Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#device-override-layer">Device Override Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#custom-user-layers">Custom (User) Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/requirements.html">System Requirements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#hardware-requirements">Hardware Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#software-requirements">Software Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#supported-graphics-apis">Supported Graphics APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#id2">2024.4 (12/12/202)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#new">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#changed">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#fixed">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#id3">2024.3 (09/12/2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id4">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id5">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id6">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-13-2024">2024.2 (June 13 2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id7">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id8">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id9">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-15-2024">2024.1 (March 15 2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id10">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id11">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id12">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#dec-14-2023">2023.4 (Dec 14 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id13">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id14">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id15">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#sept-21-2023">2023.3 (Sept 21 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id16">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id17">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id18">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2023">2023.2 (15 June 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id19">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id20">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id21">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2023">2023.1 (15 March 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id22">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id23">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id24">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2022">2022.4 (15 December 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id25">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id26">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id27">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#deprecated">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2022">2022.3 (15 September 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id28">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id29">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id30">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2022">2022.2 (30 June 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id31">New</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2022">2022.1 (16 March 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id32">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id33">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id34">Changed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2021">2021.4 (16 December 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id35">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id36">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id37">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2021">2021.3 (23 September 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id38">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id39">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id40">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2021">2021.2 (24 June 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id41">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id42">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id43">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2021">2021.1 (24 March 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id44">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id45">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id46">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#january-2021">2020.4.1 (21 January 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id47">NEW</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2020">2020.4 (14 December 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id48">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id49">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id50">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2020">2020.3 (24 September 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id51">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id52">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id53">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2020">2020.2 (25 June 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id54">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id57">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id58">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2020">2020.1 (26 March 2020)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2019">2019.4 (19 December 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2019">2019.3 (26 September 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2019">2019.2 (27 June 2019)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#known-issues-and-limitations">Known Issues and Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id2">2024.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id5">2024.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id8">2024.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id13">2024.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id18">2023.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id23">2023.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id26">2023.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id29">2023.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id32">2022.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id33">2022.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id34">2022.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id35">2022.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id36">2021.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id37">2021.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id38">2021.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id39">2020.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id40">2019.2</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/licenses.html">Legal Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/licenses.html#third-party-content">Third Party Content</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/disclaimer.html">Notices &amp; Disclaimers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Intel® GPA Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File spirv_common.hpp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-spirv-common-hpp">
<span id="program-listing-file-include-spirv-cross-spirv-common-hpp"></span><h1>Program Listing for File spirv_common.hpp<a class="headerlink" href="#program-listing-for-file-spirv-common-hpp" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file_include_spirv_cross_spirv_common.hpp.html#file-include-spirv-cross-spirv-common-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">include\spirv_cross\spirv_common.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright 2015-2021 Arm Limited</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0 OR MIT</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * At your option, you may choose to accept this material under either:</span>
<span class="cm"> *  1. The Apache License, Version 2.0, found at &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;, or</span>
<span class="cm"> *  2. The MIT License, found at &lt;http://opensource.org/licenses/MIT&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef SPIRV_CROSS_COMMON_HPP</span>
<span class="cp">#define SPIRV_CROSS_COMMON_HPP</span>

<span class="cp">#ifndef SPV_ENABLE_UTILITY_CODE</span>
<span class="cp">#define SPV_ENABLE_UTILITY_CODE</span>
<span class="cp">#endif</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv.hpp&quot;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv_cross_containers.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv_cross_error_handling.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;functional&gt;</span>

<span class="c1">// A bit crude, but allows projects which embed SPIRV-Cross statically to</span>
<span class="c1">// effectively hide all the symbols from other projects.</span>
<span class="c1">// There is a case where we have:</span>
<span class="c1">// - Project A links against SPIRV-Cross statically.</span>
<span class="c1">// - Project A links against Project B statically.</span>
<span class="c1">// - Project B links against SPIRV-Cross statically (might be a different version).</span>
<span class="c1">// This leads to a conflict with extremely bizarre results.</span>
<span class="c1">// By overriding the namespace in one of the project builds, we can work around this.</span>
<span class="c1">// If SPIRV-Cross is embedded in dynamic libraries,</span>
<span class="c1">// prefer using -fvisibility=hidden on GCC/Clang instead.</span>
<span class="cp">#ifdef SPIRV_CROSS_NAMESPACE_OVERRIDE</span>
<span class="cp">#define SPIRV_CROSS_NAMESPACE SPIRV_CROSS_NAMESPACE_OVERRIDE</span>
<span class="cp">#else</span>
<span class="cp">#define SPIRV_CROSS_NAMESPACE spirv_cross</span>
<span class="cp">#endif</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">SPIRV_CROSS_NAMESPACE</span>
<span class="p">{</span>
<span class="k">namespace</span><span class="w"> </span><span class="nn">inner</span>
<span class="p">{</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">join_helper</span><span class="p">(</span><span class="n">StringStream</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">stream</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="w"> </span><span class="n">join_helper</span><span class="p">(</span><span class="n">StringStream</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">stream</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="w">    </span><span class="n">join_helper</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...);</span>
<span class="p">}</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace inner</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Bitset</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">Bitset</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">Bitset</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">lower_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">lower</span><span class="p">(</span><span class="n">lower_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">get</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bit</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">lower</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1ull</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bit</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">higher</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">bit</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">set</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bit</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span>
<span class="w">            </span><span class="n">lower</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="mi">1ull</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bit</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">higher</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">clear</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bit</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bit</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">)</span>
<span class="w">            </span><span class="n">lower</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">1ull</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">bit</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="n">higher</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">bit</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">get_lower</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">lower</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">reset</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">lower</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">higher</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">merge_and</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">lower</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">tmp_set</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">higher</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">higher</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="n">tmp_set</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="n">higher</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">tmp_set</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">merge_or</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">lower</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">lower</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">higher</span><span class="p">)</span>
<span class="w">            </span><span class="n">higher</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lower</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">lower</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">higher</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">higher</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">higher</span><span class="p">)</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">higher</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">Op</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">for_each_bit</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Op</span><span class="w"> </span><span class="o">&amp;</span><span class="n">op</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// TODO: Add ctz-based iteration.</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">lower</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1ull</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">i</span><span class="p">))</span>
<span class="w">                </span><span class="n">op</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">higher</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Need to enforce an order here for reproducible results,</span>
<span class="w">        </span><span class="c1">// but hitting this path should happen extremely rarely, so having this slow path is fine.</span>
<span class="w">        </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bits</span><span class="p">;</span>
<span class="w">        </span><span class="n">bits</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">higher</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">higher</span><span class="p">)</span>
<span class="w">            </span><span class="n">bits</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">bits</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">bits</span><span class="p">));</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">bits</span><span class="p">)</span>
<span class="w">            </span><span class="n">op</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">lower</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">higher</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// The most common bits to set are all lower than 64,</span>
<span class="w">    </span><span class="c1">// so optimize for this case. Bits spilling outside 64 go into a slower data structure.</span>
<span class="w">    </span><span class="c1">// In almost all cases, higher data structure will not be used.</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">lower</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">higher</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Helper template to avoid lots of nasty string temporary munging.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">Ts</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">StringStream</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span>
<span class="w">    </span><span class="n">inner</span><span class="o">::</span><span class="n">join_helper</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">merge</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">between</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">StringStream</span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="n">stream</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">elem</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">list</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">stream</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">elem</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">list</span><span class="p">.</span><span class="n">back</span><span class="p">())</span>
<span class="w">            </span><span class="n">stream</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">between</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">stream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Make sure we don&#39;t accidentally call this with float or doubles with SFINAE.</span>
<span class="c1">// Have to use the radix-aware overload.</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="w"> </span><span class="nc">std</span><span class="o">::</span><span class="n">enable_if</span><span class="o">&lt;!</span><span class="n">std</span><span class="o">::</span><span class="n">is_floating_point</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="o">&gt;</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">convert_to_string</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">convert_to_string</span><span class="p">(</span><span class="kt">int32_t</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// INT_MIN is ... special on some backends. If we use a decimal literal, and negate it, we</span>
<span class="w">    </span><span class="c1">// could accidentally promote the literal to long first, then negate.</span>
<span class="w">    </span><span class="c1">// To workaround it, emit int(0x80000000) instead.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">)())</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="s">&quot;int(0x80000000)&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">convert_to_string</span><span class="p">(</span><span class="kt">int64_t</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">int64_type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">long_long_literal_suffix</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// INT64_MIN is ... special on some backends.</span>
<span class="w">    </span><span class="c1">// If we use a decimal literal, and negate it, we might overflow the representable numbers.</span>
<span class="w">    </span><span class="c1">// To workaround it, emit int(0x80000000) instead.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">value</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int64_t</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">)())</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="n">int64_type</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;(0x8000000000000000u&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">long_long_literal_suffix</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;ll&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;l&quot;</span><span class="p">),</span><span class="w"> </span><span class="s">&quot;)&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">long_long_literal_suffix</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="s">&quot;ll&quot;</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">&quot;l&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Allow implementations to set a convenient standard precision</span>
<span class="cp">#ifndef SPIRV_CROSS_FLT_FMT</span>
<span class="cp">#define SPIRV_CROSS_FLT_FMT &quot;%.32g&quot;</span>
<span class="cp">#endif</span>

<span class="c1">// Disable sprintf and strcat warnings.</span>
<span class="c1">// We cannot rely on snprintf and family existing because, ..., MSVC.</span>
<span class="cp">#if defined(__clang__) || defined(__GNUC__)</span>
<span class="cp">#pragma GCC diagnostic push</span>
<span class="cp">#pragma GCC diagnostic ignored &quot;-Wdeprecated-declarations&quot;</span>
<span class="cp">#elif defined(_MSC_VER)</span>
<span class="cp">#pragma warning(push)</span>
<span class="cp">#pragma warning(disable : 4996)</span>
<span class="cp">#endif</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">fixup_radix_point</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">radix_point</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Setting locales is a very risky business in multi-threaded program,</span>
<span class="w">    </span><span class="c1">// so just fixup locales instead. We only need to care about the radix point.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">radix_point</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">&#39;\0&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">radix_point</span><span class="p">)</span>
<span class="w">                </span><span class="o">*</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">;</span>
<span class="w">            </span><span class="n">str</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">convert_to_string</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">locale_radix_point</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// std::to_string for floating point values is broken.</span>
<span class="w">    </span><span class="c1">// Fallback to something more sane.</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="w">    </span><span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRV_CROSS_FLT_FMT</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">    </span><span class="n">fixup_radix_point</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">locale_radix_point</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Ensure that the literal is float.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">))</span>
<span class="w">        </span><span class="n">strcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;.0&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">convert_to_string</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">locale_radix_point</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// std::to_string for floating point values is broken.</span>
<span class="w">    </span><span class="c1">// Fallback to something more sane.</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
<span class="w">    </span><span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRV_CROSS_FLT_FMT</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="p">);</span>
<span class="w">    </span><span class="n">fixup_radix_point</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">locale_radix_point</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Ensure that the literal is float.</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;.&#39;</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">strchr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;e&#39;</span><span class="p">))</span>
<span class="w">        </span><span class="n">strcat</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;.0&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if defined(__clang__) || defined(__GNUC__)</span>
<span class="cp">#pragma GCC diagnostic pop</span>
<span class="cp">#elif defined(_MSC_VER)</span>
<span class="cp">#pragma warning(pop)</span>
<span class="cp">#endif</span>

<span class="k">class</span><span class="w"> </span><span class="nc">FloatFormatter</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">FloatFormatter</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">format_float</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">format_double</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ValueSaver</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">ValueSaver</span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">current</span><span class="p">(</span><span class="n">current_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">saved</span><span class="p">(</span><span class="n">current_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">release</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saved</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">~</span><span class="n">ValueSaver</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">release</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">current</span><span class="p">;</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="n">saved</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Instruction</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// If offset is 0 (not a valid offset into the instruction stream),</span>
<span class="w">    </span><span class="c1">// we have an instruction stream which is embedded in the object.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_embedded</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">EmbeddedInstruction</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">Instruction</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ops</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">Types</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">TypeNone</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeType</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeVariable</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeConstant</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeFunction</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeFunctionPrototype</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeBlock</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeExtension</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeExpression</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeConstantOp</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeCombinedImageSampler</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeAccessChain</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeUndef</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeString</span><span class="p">,</span>
<span class="w">    </span><span class="n">TypeCount</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Types</span><span class="w"> </span><span class="n">type</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TypedID</span><span class="p">;</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TypedID</span><span class="o">&lt;</span><span class="n">TypeNone</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">TypedID</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="n">TypedID</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Types</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">TypedID</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="k">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Types</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">TypedID</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Implicit conversion to u32 is desired here.</span>
<span class="w">    </span><span class="c1">// As long as we block implicit conversion between TypedID&lt;A&gt; and TypedID&lt;B&gt; we&#39;re good.</span>
<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Types</span><span class="w"> </span><span class="n">U</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Types</span><span class="w"> </span><span class="n">type</span><span class="o">&gt;</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TypedID</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">TypedID</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="n">TypedID</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">TypedID</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">TypeNone</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">operator</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span><span class="w"> </span><span class="n">VariableID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">TypeVariable</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">TypeID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">TypeType</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">ConstantID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">TypeConstant</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">FunctionID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">TypeFunction</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">BlockID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">TypeBlock</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">TypeNone</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// Helper for Variant interface.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">IVariant</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">IVariant</span><span class="w"> </span><span class="o">*</span><span class="nf">clone</span><span class="p">(</span><span class="n">ObjectPoolBase</span><span class="w"> </span><span class="o">*</span><span class="n">pool</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="n">IVariant</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="n">IVariant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">IVariant</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="n">IVariant</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">IVariant</span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define SPIRV_CROSS_DECLARE_CLONE(T)                                \</span>
<span class="cp">    IVariant *clone(ObjectPoolBase *pool) override                  \</span>
<span class="cp">    {                                                               \</span>
<span class="cp">        return static_cast&lt;ObjectPool&lt;T&gt; *&gt;(pool)-&gt;allocate(*this); \</span>
<span class="cp">    }</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRUndef</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeUndef</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">SPIRUndef</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">basetype_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">basetype</span><span class="p">(</span><span class="n">basetype_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">basetype</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRUndef</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRString</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeString</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">SPIRString</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">str</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">str_</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">str</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRString</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// This type is only used by backends which need to access the combined image and sampler IDs separately after</span>
<span class="c1">// the OpSampledImage opcode.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRCombinedImageSampler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeCombinedImageSampler</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">SPIRCombinedImageSampler</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">type_</span><span class="p">,</span><span class="w"> </span><span class="n">VariableID</span><span class="w"> </span><span class="n">image_</span><span class="p">,</span><span class="w"> </span><span class="n">VariableID</span><span class="w"> </span><span class="n">sampler_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">combined_type</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">image</span><span class="p">(</span><span class="n">image_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">sampler</span><span class="p">(</span><span class="n">sampler_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">combined_type</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">image</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">sampler</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRCombinedImageSampler</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRConstantOp</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeConstantOp</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">SPIRConstantOp</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">opcode</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">basetype</span><span class="p">(</span><span class="n">result_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">arguments</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">arguments</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arguments</span><span class="p">;</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">basetype</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRConstantOp</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRType</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeType</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="o">::</span><span class="n">OpNop</span><span class="p">;</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">SPIRType</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op_</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">op</span><span class="p">(</span><span class="n">op_</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">BaseType</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Unknown</span><span class="p">,</span>
<span class="w">        </span><span class="n">Void</span><span class="p">,</span>
<span class="w">        </span><span class="n">Boolean</span><span class="p">,</span>
<span class="w">        </span><span class="n">SByte</span><span class="p">,</span>
<span class="w">        </span><span class="n">UByte</span><span class="p">,</span>
<span class="w">        </span><span class="n">Short</span><span class="p">,</span>
<span class="w">        </span><span class="n">UShort</span><span class="p">,</span>
<span class="w">        </span><span class="n">Int</span><span class="p">,</span>
<span class="w">        </span><span class="n">UInt</span><span class="p">,</span>
<span class="w">        </span><span class="n">Int64</span><span class="p">,</span>
<span class="w">        </span><span class="n">UInt64</span><span class="p">,</span>
<span class="w">        </span><span class="n">AtomicCounter</span><span class="p">,</span>
<span class="w">        </span><span class="n">Half</span><span class="p">,</span>
<span class="w">        </span><span class="n">Float</span><span class="p">,</span>
<span class="w">        </span><span class="n">Double</span><span class="p">,</span>
<span class="w">        </span><span class="n">Struct</span><span class="p">,</span>
<span class="w">        </span><span class="n">Image</span><span class="p">,</span>
<span class="w">        </span><span class="n">SampledImage</span><span class="p">,</span>
<span class="w">        </span><span class="n">Sampler</span><span class="p">,</span>
<span class="w">        </span><span class="n">AccelerationStructure</span><span class="p">,</span>
<span class="w">        </span><span class="n">RayQuery</span><span class="p">,</span>

<span class="w">        </span><span class="c1">// Keep internal types at the end.</span>
<span class="w">        </span><span class="n">ControlPointArray</span><span class="p">,</span>
<span class="w">        </span><span class="n">Interpolant</span><span class="p">,</span>
<span class="w">        </span><span class="n">Char</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Scalar/vector/matrix support.</span>
<span class="w">    </span><span class="n">BaseType</span><span class="w"> </span><span class="n">basetype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Unknown</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vecsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Arrays, support array of arrays by having a vector of array sizes.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Array elements can be either specialization constants or specialization ops.</span>
<span class="w">    </span><span class="c1">// This array determines how to interpret the array size.</span>
<span class="w">    </span><span class="c1">// If an element is true, the element is a literal,</span>
<span class="w">    </span><span class="c1">// otherwise, it&#39;s an expression, which must be resolved on demand.</span>
<span class="w">    </span><span class="c1">// The actual size is not really known until runtime.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array_size_literal</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Pointers</span>
<span class="w">    </span><span class="c1">// Keep track of how many pointer layers we have.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">pointer_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">forward_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClassGeneric</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">TypeID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">member_types</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If member order has been rewritten to handle certain scenarios with Offset,</span>
<span class="w">    </span><span class="c1">// allow codegen to rewrite the index.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">member_type_index_redirection</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ImageType</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">TypeID</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">        </span><span class="n">spv</span><span class="o">::</span><span class="n">Dim</span><span class="w"> </span><span class="n">dim</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">arrayed</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">ms</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">sampled</span><span class="p">;</span>
<span class="w">        </span><span class="n">spv</span><span class="o">::</span><span class="n">ImageFormat</span><span class="w"> </span><span class="n">format</span><span class="p">;</span>
<span class="w">        </span><span class="n">spv</span><span class="o">::</span><span class="n">AccessQualifier</span><span class="w"> </span><span class="n">access</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">image</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="c1">// Structs can be declared multiple times if they are used as part of interface blocks.</span>
<span class="w">    </span><span class="c1">// We want to detect this so that we only emit the struct definition once.</span>
<span class="w">    </span><span class="c1">// Since we cannot rely on OpName to be equal, we need to figure out aliases.</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">type_alias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Denotes the type which this type is based on.</span>
<span class="w">    </span><span class="c1">// Allows the backend to traverse how a complex type is built up during access chains.</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">parent_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Used in backends to avoid emitting members with conflicting names.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">member_name_cache</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRType</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRExtension</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeExtension</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Extension</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Unsupported</span><span class="p">,</span>
<span class="w">        </span><span class="n">GLSL</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPV_debug_info</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPV_AMD_shader_ballot</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPV_AMD_shader_explicit_vertex_parameter</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPV_AMD_shader_trinary_minmax</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPV_AMD_gcn_shader</span><span class="p">,</span>
<span class="w">        </span><span class="n">NonSemanticDebugPrintf</span><span class="p">,</span>
<span class="w">        </span><span class="n">NonSemanticShaderDebugInfo</span><span class="p">,</span>
<span class="w">        </span><span class="n">NonSemanticGeneric</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">SPIRExtension</span><span class="p">(</span><span class="n">Extension</span><span class="w"> </span><span class="n">ext_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">ext</span><span class="p">(</span><span class="n">ext_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Extension</span><span class="w"> </span><span class="n">ext</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRExtension</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// SPIREntryPoint is not a variant since its IDs are used to decorate OpFunction,</span>
<span class="c1">// so in order to avoid conflicts, we can&#39;t stick them in the ids array.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">SPIREntryPoint</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">SPIREntryPoint</span><span class="p">(</span><span class="n">FunctionID</span><span class="w"> </span><span class="n">self_</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">execution_model</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">entry_name</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">self</span><span class="p">(</span><span class="n">self_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">(</span><span class="n">entry_name</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">orig_name</span><span class="p">(</span><span class="n">entry_name</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">model</span><span class="p">(</span><span class="n">execution_model</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">SPIREntryPoint</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">    </span><span class="n">FunctionID</span><span class="w"> </span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">orig_name</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">interface_variables</span><span class="p">;</span>

<span class="w">    </span><span class="n">Bitset</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">WorkgroupSize</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">id_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">id_z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// Workgroup size can be expressed as a constant/spec-constant instead.</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">workgroup_size</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">invocations</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">output_vertices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">output_primitives</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModelMax</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">geometry_passthrough</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRExpression</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeExpression</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Only created by the backend target to avoid creating tons of temporaries.</span>
<span class="w">    </span><span class="n">SPIRExpression</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="n">TypeID</span><span class="w"> </span><span class="n">expression_type_</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">immutable_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">expression</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">expression_type</span><span class="p">(</span><span class="n">expression_type_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">immutable</span><span class="p">(</span><span class="n">immutable_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If non-zero, prepend expression with to_expression(base_expression).</span>
<span class="w">    </span><span class="c1">// Used in amortizing multiple calls to to_expression()</span>
<span class="w">    </span><span class="c1">// where in certain cases that would quickly force a temporary when not needed.</span>
<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">base_expression</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">expression</span><span class="p">;</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">expression_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If this expression is a forwarded load,</span>
<span class="w">    </span><span class="c1">// allow us to reference the original variable.</span>
<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">loaded_from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If this expression will never change, we can avoid lots of temporaries</span>
<span class="w">    </span><span class="c1">// in high level source.</span>
<span class="w">    </span><span class="c1">// An expression being immutable can be speculative,</span>
<span class="w">    </span><span class="c1">// it is assumed that this is true almost always.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">immutable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Before use, this expression must be transposed.</span>
<span class="w">    </span><span class="c1">// This is needed for targets which don&#39;t support row_major layouts.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_transpose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Whether or not this is an access chain expression.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">access_chain</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Whether or not gl_MeshVerticesEXT[].gl_Position (as a whole or .y) is referenced</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">access_meshlet_position_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// A list of expressions which this expression depends on.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">expression_dependencies</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// By reading this expression, we implicitly read these expressions as well.</span>
<span class="w">    </span><span class="c1">// Used by access chain Store and Load since we read multiple expressions in this case.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">implied_read_expressions</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The expression was emitted at a certain scope. Lets us track when an expression read means multiple reads.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">emitted_loop_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRExpression</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRFunctionPrototype</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeFunctionPrototype</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">SPIRFunctionPrototype</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">return_type_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">return_type</span><span class="p">(</span><span class="n">return_type_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">return_type</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parameter_types</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRFunctionPrototype</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRBlock</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeBlock</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Terminator</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Unknown</span><span class="p">,</span>
<span class="w">        </span><span class="n">Direct</span><span class="p">,</span><span class="w"> </span><span class="c1">// Emit next block directly without a particular condition.</span>

<span class="w">        </span><span class="n">Select</span><span class="p">,</span><span class="w"> </span><span class="c1">// Block ends with an if/else block.</span>
<span class="w">        </span><span class="n">MultiSelect</span><span class="p">,</span><span class="w"> </span><span class="c1">// Block ends with switch statement.</span>

<span class="w">        </span><span class="n">Return</span><span class="p">,</span><span class="w"> </span><span class="c1">// Block ends with return.</span>
<span class="w">        </span><span class="n">Unreachable</span><span class="p">,</span><span class="w"> </span><span class="c1">// Noop</span>
<span class="w">        </span><span class="n">Kill</span><span class="p">,</span><span class="w"> </span><span class="c1">// Discard</span>
<span class="w">        </span><span class="n">IgnoreIntersection</span><span class="p">,</span><span class="w"> </span><span class="c1">// Ray Tracing</span>
<span class="w">        </span><span class="n">TerminateRay</span><span class="p">,</span><span class="w"> </span><span class="c1">// Ray Tracing</span>
<span class="w">        </span><span class="n">EmitMeshTasks</span><span class="w"> </span><span class="c1">// Mesh shaders</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Merge</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">MergeNone</span><span class="p">,</span>
<span class="w">        </span><span class="n">MergeLoop</span><span class="p">,</span>
<span class="w">        </span><span class="n">MergeSelection</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Hints</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">HintNone</span><span class="p">,</span>
<span class="w">        </span><span class="n">HintUnroll</span><span class="p">,</span>
<span class="w">        </span><span class="n">HintDontUnroll</span><span class="p">,</span>
<span class="w">        </span><span class="n">HintFlatten</span><span class="p">,</span>
<span class="w">        </span><span class="n">HintDontFlatten</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">Method</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">MergeToSelectForLoop</span><span class="p">,</span>
<span class="w">        </span><span class="n">MergeToDirectForLoop</span><span class="p">,</span>
<span class="w">        </span><span class="n">MergeToSelectContinueForLoop</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">ContinueBlockType</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ContinueNone</span><span class="p">,</span>

<span class="w">        </span><span class="c1">// Continue block is branchless and has at least one instruction.</span>
<span class="w">        </span><span class="n">ForLoop</span><span class="p">,</span>

<span class="w">        </span><span class="c1">// Noop continue block.</span>
<span class="w">        </span><span class="n">WhileLoop</span><span class="p">,</span>

<span class="w">        </span><span class="c1">// Continue block is conditional.</span>
<span class="w">        </span><span class="n">DoWhileLoop</span><span class="p">,</span>

<span class="w">        </span><span class="c1">// Highly unlikely that anything will use this,</span>
<span class="w">        </span><span class="c1">// since it is really awkward/impossible to express in GLSL.</span>
<span class="w">        </span><span class="n">ComplexLoop</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="nl">enum</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="kt">uint32_t</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">NoDominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffffu</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Terminator</span><span class="w"> </span><span class="n">terminator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Unknown</span><span class="p">;</span>
<span class="w">    </span><span class="n">Merge</span><span class="w"> </span><span class="n">merge</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MergeNone</span><span class="p">;</span>
<span class="w">    </span><span class="n">Hints</span><span class="w"> </span><span class="n">hint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">HintNone</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">next_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">merge_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">continue_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">return_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="c1">// If 0, return nothing (void).</span>
<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">true_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">false_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">default_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If terminator is EmitMeshTasksEXT.</span>
<span class="w">    </span><span class="k">struct</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ID</span><span class="w"> </span><span class="n">groups</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="w">        </span><span class="n">ID</span><span class="w"> </span><span class="n">payload</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">mesh</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Instruction</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ops</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Phi</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ID</span><span class="w"> </span><span class="n">local_variable</span><span class="p">;</span><span class="w"> </span><span class="c1">// flush local variable ...</span>
<span class="w">        </span><span class="n">BlockID</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"> </span><span class="c1">// If we&#39;re in from_block and want to branch into this block ...</span>
<span class="w">        </span><span class="n">VariableID</span><span class="w"> </span><span class="n">function_variable</span><span class="p">;</span><span class="w"> </span><span class="c1">// to this function-global &quot;phi&quot; variable first.</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Before entering this block flush out local variables to magical &quot;phi&quot; variables.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Phi</span><span class="o">&gt;</span><span class="w"> </span><span class="n">phi_variables</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Declare these temporaries before beginning the block.</span>
<span class="w">    </span><span class="c1">// Used for handling complex continue blocks which have side effects.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TypeID</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">declare_temporary</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Declare these temporaries, but only conditionally if this block turns out to be</span>
<span class="w">    </span><span class="c1">// a complex loop header.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TypeID</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">potential_declare_temporary</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Case</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">        </span><span class="n">BlockID</span><span class="w"> </span><span class="n">block</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Case</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cases_32bit</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Case</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cases_64bit</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If we have tried to optimize code for this block but failed,</span>
<span class="w">    </span><span class="c1">// keep track of this.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">disable_block_optimization</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If the continue block is complex, fallback to &quot;dumb&quot; for loops.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">complex_continue</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Do we need a ladder variable to defer breaking out of a loop construct after a switch block?</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_ladder_break</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If marked, we have explicitly handled Phi from this block, so skip any flushes related to that on a branch.</span>
<span class="w">    </span><span class="c1">// Used to handle an edge case with switch and case-label fallthrough where fall-through writes to Phi.</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">ignore_phi_from_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The dominating block which this block might be within.</span>
<span class="w">    </span><span class="c1">// Used in continue; blocks to determine if we really need to write continue.</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">loop_dominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// All access to these variables are dominated by this block,</span>
<span class="w">    </span><span class="c1">// so before branching anywhere we need to make sure that we declare these variables.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dominated_variables</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// These are variables which should be declared in a for loop header, if we</span>
<span class="w">    </span><span class="c1">// fail to use a classic for-loop,</span>
<span class="w">    </span><span class="c1">// we remove these variables, and fall back to regular variables outside the loop.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">loop_variables</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Some expressions are control-flow dependent, i.e. any instruction which relies on derivatives or</span>
<span class="w">    </span><span class="c1">// sub-group-like operations.</span>
<span class="w">    </span><span class="c1">// Make sure that we only use these expressions in the original block.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">invalidate_expressions</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRFunction</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeFunction</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">SPIRFunction</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">return_type_</span><span class="p">,</span><span class="w"> </span><span class="n">TypeID</span><span class="w"> </span><span class="n">function_type_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">return_type</span><span class="p">(</span><span class="n">return_type_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">function_type</span><span class="p">(</span><span class="n">function_type_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Parameter</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">TypeID</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">        </span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">read_count</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">write_count</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Set to true if this parameter aliases a global variable,</span>
<span class="w">        </span><span class="c1">// used mostly in Metal where global variables</span>
<span class="w">        </span><span class="c1">// have to be passed down to functions as regular arguments.</span>
<span class="w">        </span><span class="c1">// However, for this kind of variable, we should not care about</span>
<span class="w">        </span><span class="c1">// read and write counts as access to the function arguments</span>
<span class="w">        </span><span class="c1">// is not local to the function in question.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">alias_global_variable</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// When calling a function, and we&#39;re remapping separate image samplers,</span>
<span class="w">    </span><span class="c1">// resolve these arguments into combined image samplers and pass them</span>
<span class="w">    </span><span class="c1">// as additional arguments in this order.</span>
<span class="w">    </span><span class="c1">// It gets more complicated as functions can pull in their own globals</span>
<span class="w">    </span><span class="c1">// and combine them with parameters,</span>
<span class="w">    </span><span class="c1">// so we need to distinguish if something is local parameter index</span>
<span class="w">    </span><span class="c1">// or a global ID.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CombinedImageSamplerParameter</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">        </span><span class="n">VariableID</span><span class="w"> </span><span class="n">image_id</span><span class="p">;</span>
<span class="w">        </span><span class="n">VariableID</span><span class="w"> </span><span class="n">sampler_id</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">global_image</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">global_sampler</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">depth</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">return_type</span><span class="p">;</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">function_type</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Parameter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">arguments</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Can be used by backends to add magic arguments.</span>
<span class="w">    </span><span class="c1">// Currently used by combined image/sampler implementation.</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Parameter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shadow_arguments</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">local_variables</span><span class="p">;</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">entry_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BlockID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">blocks</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CombinedImageSamplerParameter</span><span class="o">&gt;</span><span class="w"> </span><span class="n">combined_parameters</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">EntryLine</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">file_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">line_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">EntryLine</span><span class="w"> </span><span class="n">entry_line</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_local_variable</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">local_variables</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_parameter</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">parameter_type</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">alias_global_variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Arguments are read-only until proven otherwise.</span>
<span class="w">        </span><span class="n">arguments</span><span class="p">.</span><span class="n">push_back</span><span class="p">({</span><span class="w"> </span><span class="n">parameter_type</span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="mi">0u</span><span class="p">,</span><span class="w"> </span><span class="mi">0u</span><span class="p">,</span><span class="w"> </span><span class="n">alias_global_variable</span><span class="w"> </span><span class="p">});</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Hooks to be run when the function returns.</span>
<span class="w">    </span><span class="c1">// Mostly used for lowering internal data structures onto flattened structures.</span>
<span class="w">    </span><span class="c1">// Need to defer this, because they might rely on things which change during compilation.</span>
<span class="w">    </span><span class="c1">// Intentionally not a small vector, this one is rare, and std::function can be large.</span>
<span class="w">    </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fixup_hooks_out</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Hooks to be run when the function begins.</span>
<span class="w">    </span><span class="c1">// Mostly used for populating internal data structures from flattened structures.</span>
<span class="w">    </span><span class="c1">// Need to defer this, because they might rely on things which change during compilation.</span>
<span class="w">    </span><span class="c1">// Intentionally not a small vector, this one is rare, and std::function can be large.</span>
<span class="w">    </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">fixup_hooks_in</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// On function entry, make sure to copy a constant array into thread addr space to work around</span>
<span class="w">    </span><span class="c1">// the case where we are passing a constant array by value to a function on backends which do not</span>
<span class="w">    </span><span class="c1">// consider arrays value types.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">constant_arrays_needed_on_stack</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">flush_undeclared</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">do_combined_parameters</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRAccessChain</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeAccessChain</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">SPIRAccessChain</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">basetype_</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage_</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">base_</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">dynamic_index_</span><span class="p">,</span>
<span class="w">                    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">static_index_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">basetype</span><span class="p">(</span><span class="n">basetype_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">storage</span><span class="p">(</span><span class="n">storage_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">base</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">base_</span><span class="p">))</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">dynamic_index</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">dynamic_index_</span><span class="p">))</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">static_index</span><span class="p">(</span><span class="n">static_index_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// The access chain represents an offset into a buffer.</span>
<span class="w">    </span><span class="c1">// Some backends need more complicated handling of access chains to be able to use buffers, like HLSL</span>
<span class="w">    </span><span class="c1">// which has no usable buffer type ala GLSL SSBOs.</span>
<span class="w">    </span><span class="c1">// StructuredBuffer is too limited, so our only option is to deal with ByteAddressBuffer which works with raw addresses.</span>

<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">basetype</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">base</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">dynamic_index</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">static_index</span><span class="p">;</span>

<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">loaded_from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">matrix_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">array_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">row_major_matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">immutable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// By reading this expression, we implicitly read these expressions as well.</span>
<span class="w">    </span><span class="c1">// Used by access chain Store and Load since we read multiple expressions in this case.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">implied_read_expressions</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRAccessChain</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRVariable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeVariable</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">SPIRVariable</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRVariable</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">basetype_</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage_</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="n">initializer_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">VariableID</span><span class="w"> </span><span class="n">basevariable_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">basetype</span><span class="p">(</span><span class="n">basetype_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">storage</span><span class="p">(</span><span class="n">storage_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">initializer</span><span class="p">(</span><span class="n">initializer_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">basevariable</span><span class="p">(</span><span class="n">basevariable_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">basetype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClassGeneric</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">decoration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">initializer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">basevariable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dereference_chain</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">compat_builtin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If a variable is shadowed, we only statically assign to it</span>
<span class="w">    </span><span class="c1">// and never actually emit a statement for it.</span>
<span class="w">    </span><span class="c1">// When we read the variable as an expression, just forward</span>
<span class="w">    </span><span class="c1">// shadowed_id as the expression.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">statically_assigned</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">static_expression</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Temporaries which can remain forwarded as long as this variable is not modified.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dependees</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">deferred_declaration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">phi_variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Used to deal with Phi variable flushes. See flush_phi().</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">allocate_temporary_copy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">remapped_variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">remapped_components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The block which dominates all access to this variable.</span>
<span class="w">    </span><span class="n">BlockID</span><span class="w"> </span><span class="n">dominator</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// If true, this variable is a loop variable, when accessing the variable</span>
<span class="w">    </span><span class="c1">// outside a loop,</span>
<span class="w">    </span><span class="c1">// we should statically forward it.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">loop_variable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Set to true while we&#39;re inside the for loop.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">loop_variable_enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Used to find global LUTs</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_written_to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRFunction</span><span class="o">::</span><span class="n">Parameter</span><span class="w"> </span><span class="o">*</span><span class="n">parameter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRVariable</span><span class="p">)</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SPIRConstant</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IVariant</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">enum</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeConstant</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="nc">Constant</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">u32</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">i32</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">f32</span><span class="p">;</span>

<span class="w">        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">u64</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int64_t</span><span class="w"> </span><span class="n">i64</span><span class="p">;</span>
<span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">f64</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ConstantVector</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Constant</span><span class="w"> </span><span class="n">r</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="c1">// If != 0, this element is a specialization constant, and we should keep track of it as such.</span>
<span class="w">        </span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vecsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="n">ConstantVector</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">memset</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">r</span><span class="p">));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ConstantMatrix</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ConstantVector</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="c1">// If != 0, this column is a specialization constant, and we should keep track of it as such.</span>
<span class="w">        </span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">f16_to_f32</span><span class="p">(</span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">u16_value</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Based on the GLM implementation.</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u16_value</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u16_value</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x1f</span><span class="p">;</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">u16_value</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x3ff</span><span class="p">;</span>

<span class="w">        </span><span class="k">union</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">f32</span><span class="p">;</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">u32</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">u</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">u</span><span class="p">.</span><span class="n">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">31</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">f32</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">m</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x400</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">                    </span><span class="n">e</span><span class="o">--</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>

<span class="w">                </span><span class="n">e</span><span class="o">++</span><span class="p">;</span>
<span class="w">                </span><span class="n">m</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="mh">0x400</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">u</span><span class="p">.</span><span class="n">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x7f800000u</span><span class="p">;</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">f32</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">u</span><span class="p">.</span><span class="n">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mh">0x7f800000u</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">13</span><span class="p">);</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">f32</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">e</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">127</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">15</span><span class="p">;</span>
<span class="w">        </span><span class="n">m</span><span class="w"> </span><span class="o">&lt;&lt;=</span><span class="w"> </span><span class="mi">13</span><span class="p">;</span>
<span class="w">        </span><span class="n">u</span><span class="p">.</span><span class="n">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">31</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">23</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">u</span><span class="p">.</span><span class="n">f32</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">specialization_constant_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">id</span><span class="p">[</span><span class="n">row</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">specialization_constant_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">[</span><span class="n">col</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">scalar</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">u32</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int16_t</span><span class="w"> </span><span class="nf">scalar_i16</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kt">int16_t</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">u32</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffffu</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint16_t</span><span class="w"> </span><span class="nf">scalar_u16</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kt">uint16_t</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">u32</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffffu</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int8_t</span><span class="w"> </span><span class="nf">scalar_i8</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kt">int8_t</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">u32</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffu</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="nf">scalar_u8</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kt">uint8_t</span><span class="p">(</span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">u32</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xffu</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">scalar_f16</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">f16_to_f32</span><span class="p">(</span><span class="n">scalar_u16</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">scalar_f32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">f32</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int32_t</span><span class="w"> </span><span class="nf">scalar_i32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">i32</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">scalar_f64</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">f64</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">int64_t</span><span class="w"> </span><span class="nf">scalar_i64</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">i64</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="nf">scalar_u64</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">col</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">row</span><span class="p">].</span><span class="n">u64</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">ConstantVector</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">vector</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">vector_size</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vecsize</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">columns</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">columns</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">make_null</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">constant_type_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{};</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">columns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">constant_type_</span><span class="p">.</span><span class="n">columns</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">)</span>
<span class="w">            </span><span class="n">c</span><span class="p">.</span><span class="n">vecsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">constant_type_</span><span class="p">.</span><span class="n">vecsize</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">constant_is_null</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">specialization</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">subconstants</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">columns</span><span class="p">();</span><span class="w"> </span><span class="n">col</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">vector_size</span><span class="p">();</span><span class="w"> </span><span class="n">row</span><span class="o">++</span><span class="p">)</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">scalar_u64</span><span class="p">(</span><span class="n">col</span><span class="p">,</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">constant_type_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">constant_type</span><span class="p">(</span><span class="n">constant_type_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">SPIRConstant</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRConstant</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">constant_type_</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">elements</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_elements</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">specialized</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">constant_type</span><span class="p">(</span><span class="n">constant_type_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">specialization</span><span class="p">(</span><span class="n">specialized</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">subconstants</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">num_elements</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_elements</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">subconstants</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="n">specialization</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">specialized</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Construct scalar (32-bit).</span>
<span class="w">    </span><span class="n">SPIRConstant</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">constant_type_</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">specialized</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">constant_type</span><span class="p">(</span><span class="n">constant_type_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">specialization</span><span class="p">(</span><span class="n">specialized</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">u32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v0</span><span class="p">;</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vecsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">columns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Construct scalar (64-bit).</span>
<span class="w">    </span><span class="n">SPIRConstant</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">constant_type_</span><span class="p">,</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">v0</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">specialized</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">constant_type</span><span class="p">(</span><span class="n">constant_type_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">specialization</span><span class="p">(</span><span class="n">specialized</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">u64</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v0</span><span class="p">;</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vecsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">m</span><span class="p">.</span><span class="n">columns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Construct vectors and matrices.</span>
<span class="w">    </span><span class="n">SPIRConstant</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">constant_type_</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">*</span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">vector_elements</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_elements</span><span class="p">,</span>
<span class="w">                 </span><span class="kt">bool</span><span class="w"> </span><span class="n">specialized</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">constant_type</span><span class="p">(</span><span class="n">constant_type_</span><span class="p">)</span>
<span class="w">        </span><span class="p">,</span><span class="w"> </span><span class="n">specialization</span><span class="p">(</span><span class="n">specialized</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">matrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector_elements</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vecsize</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m</span><span class="p">.</span><span class="n">columns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_elements</span><span class="p">;</span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_elements</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vector_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">specialization</span><span class="p">)</span>
<span class="w">                    </span><span class="n">m</span><span class="p">.</span><span class="n">id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">vecsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_elements</span><span class="p">;</span>
<span class="w">            </span><span class="n">m</span><span class="p">.</span><span class="n">columns</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_elements</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">vector_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">specialization</span><span class="p">)</span>
<span class="w">                    </span><span class="n">m</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vector_elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">self</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">constant_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ConstantMatrix</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If this constant is a specialization constant (i.e. created with OpSpecConstant*).</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">specialization</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// If this constant is used as an array length which creates specialization restrictions on some backends.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_used_as_array_length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If true, this is a LUT, and should always be declared in the outer scope.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_used_as_lut</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// For composites which are constant arrays, etc.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ConstantID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">subconstants</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Non-Vulkan GLSL, HLSL and sometimes MSL emits defines for each specialization constant,</span>
<span class="w">    </span><span class="c1">// and uses them to initialize the constant. This allows the user</span>
<span class="w">    </span><span class="c1">// to still be able to specialize the value by supplying corresponding</span>
<span class="w">    </span><span class="c1">// preprocessor directives before compiling the shader.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">specialization_constant_macro_name</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRV_CROSS_DECLARE_CLONE</span><span class="p">(</span><span class="n">SPIRConstant</span><span class="p">)</span>
<span class="p">};</span>

<span class="c1">// Variants have a very specific allocation scheme.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">ObjectPoolGroup</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ObjectPoolBase</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pools</span><span class="p">[</span><span class="n">TypeCount</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Variant</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">Variant</span><span class="p">(</span><span class="n">ObjectPoolGroup</span><span class="w"> </span><span class="o">*</span><span class="n">group_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">group</span><span class="p">(</span><span class="n">group_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="o">~</span><span class="n">Variant</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">holder</span><span class="p">)</span>
<span class="w">            </span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">deallocate_opaque</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Marking custom move constructor as noexcept is important.</span>
<span class="w">    </span><span class="n">Variant</span><span class="p">(</span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="n">SPIRV_CROSS_NOEXCEPT</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="k">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// We cannot copy from other variant without our own pool group.</span>
<span class="w">    </span><span class="c1">// Have to explicitly copy.</span>
<span class="w">    </span><span class="n">Variant</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variant</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">delete</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Marking custom move constructor as noexcept is important.</span>
<span class="w">    </span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="n">SPIRV_CROSS_NOEXCEPT</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">holder</span><span class="p">)</span>
<span class="w">                </span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">deallocate_opaque</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>
<span class="w">            </span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">holder</span><span class="p">;</span>
<span class="w">            </span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">group</span><span class="p">;</span>
<span class="w">            </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
<span class="w">            </span><span class="n">allow_type_rewrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">allow_type_rewrite</span><span class="p">;</span>

<span class="w">            </span><span class="n">other</span><span class="p">.</span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">            </span><span class="n">other</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeNone</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// This copy/clone should only be called in the Compiler constructor.</span>
<span class="w">    </span><span class="c1">// If this is called inside ::compile(), we invalidate any references we took higher in the stack.</span>
<span class="w">    </span><span class="c1">// This should never happen.</span>
<span class="w">    </span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="c1">//#define SPIRV_CROSS_COPY_CONSTRUCTOR_SANITIZE</span>
<span class="cp">#ifdef SPIRV_CROSS_COPY_CONSTRUCTOR_SANITIZE</span>
<span class="w">        </span><span class="n">abort</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">holder</span><span class="p">)</span>
<span class="w">                </span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">deallocate_opaque</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">holder</span><span class="p">)</span>
<span class="w">                </span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">(</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">other</span><span class="p">.</span><span class="n">type</span><span class="p">].</span><span class="n">get</span><span class="p">());</span>
<span class="w">            </span><span class="k">else</span>
<span class="w">                </span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">            </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
<span class="w">            </span><span class="n">allow_type_rewrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">allow_type_rewrite</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set</span><span class="p">(</span><span class="n">IVariant</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">Types</span><span class="w"> </span><span class="n">new_type</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">holder</span><span class="p">)</span>
<span class="w">            </span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">deallocate_opaque</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>
<span class="w">        </span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">allow_type_rewrite</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">TypeNone</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">new_type</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
<span class="w">                </span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">new_type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">deallocate_opaque</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
<span class="w">            </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;Overwriting a variant with new type.&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_type</span><span class="p">;</span>
<span class="w">        </span><span class="n">allow_type_rewrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">Ts</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">allocate_and_set</span><span class="p">(</span><span class="n">Types</span><span class="w"> </span><span class="n">new_type</span><span class="p">,</span><span class="w"> </span><span class="n">Ts</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">ts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">ObjectPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">new_type</span><span class="p">]).</span><span class="n">allocate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ts</span><span class="p">)...);</span>
<span class="w">        </span><span class="n">set</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="w"> </span><span class="n">new_type</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">holder</span><span class="p">)</span>
<span class="w">            </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;nullptr&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">type</span><span class="p">)</span>
<span class="w">            </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;Bad cast&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">holder</span><span class="p">)</span>
<span class="w">            </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;nullptr&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">type</span><span class="p">)</span>
<span class="w">            </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;Bad cast&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">Types</span><span class="w"> </span><span class="n">get_type</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">get_id</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">holder</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">self</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ID</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">empty</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">holder</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">reset</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">holder</span><span class="p">)</span>
<span class="w">            </span><span class="n">group</span><span class="o">-&gt;</span><span class="n">pools</span><span class="p">[</span><span class="n">type</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">deallocate_opaque</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>
<span class="w">        </span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeNone</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_allow_type_rewrite</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">allow_type_rewrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">ObjectPoolGroup</span><span class="w"> </span><span class="o">*</span><span class="n">group</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">IVariant</span><span class="w"> </span><span class="o">*</span><span class="n">holder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">Types</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TypeNone</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">allow_type_rewrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variant_get</span><span class="p">(</span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">var</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variant_get</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">var</span><span class="p">.</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span>
<span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variant_set</span><span class="p">(</span><span class="n">Variant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var</span><span class="p">.</span><span class="n">allocate_and_set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">AccessChainMeta</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">storage_physical_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_transpose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">storage_is_packed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">storage_is_invariant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">flattened_struct</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">relaxed_precision</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">access_meshlet_position_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">ExtendedDecorations</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Marks if a buffer block is re-packed, i.e. member declaration might be subject to PhysicalTypeID remapping and padding.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationBufferBlockRepacked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// A type in a buffer block might be declared with a different physical type than the logical type.</span>
<span class="w">    </span><span class="c1">// If this is not set, PhysicalTypeID == the SPIR-V type as declared.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationPhysicalTypeID</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Marks if the physical type is to be declared with tight packing rules, i.e. packed_floatN on MSL and friends.</span>
<span class="w">    </span><span class="c1">// If this is set, PhysicalTypeID might also be set. It can be set to same as logical type if all we&#39;re doing</span>
<span class="w">    </span><span class="c1">// is converting float3 to packed_float3 for example.</span>
<span class="w">    </span><span class="c1">// If this is marked on a struct, it means the struct itself must use only Packed types for all its members.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationPhysicalTypePacked</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// The padding in bytes before declaring this struct member.</span>
<span class="w">    </span><span class="c1">// If used on a struct type, marks the target size of a struct.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationPaddingTarget</span><span class="p">,</span>

<span class="w">    </span><span class="n">SPIRVCrossDecorationInterfaceMemberIndex</span><span class="p">,</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationInterfaceOrigID</span><span class="p">,</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationResourceIndexPrimary</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// Used for decorations like resource indices for samplers when part of combined image samplers.</span>
<span class="w">    </span><span class="c1">// A variable might need to hold two resource indices in this case.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationResourceIndexSecondary</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// Used for resource indices for multiplanar images when part of combined image samplers.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationResourceIndexTertiary</span><span class="p">,</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationResourceIndexQuaternary</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Marks a buffer block for using explicit offsets (GLSL/HLSL).</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationExplicitOffset</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Apply to a variable in the Input storage class; marks it as holding the base group passed to vkCmdDispatchBase(),</span>
<span class="w">    </span><span class="c1">// or the base vertex and instance indices passed to vkCmdDrawIndexed().</span>
<span class="w">    </span><span class="c1">// In MSL, this is used to adjust the WorkgroupId and GlobalInvocationId variables in compute shaders,</span>
<span class="w">    </span><span class="c1">// and to hold the BaseVertex and BaseInstance variables in vertex shaders.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationBuiltInDispatchBase</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Apply to a variable that is a function parameter; marks it as being a &quot;dynamic&quot;</span>
<span class="w">    </span><span class="c1">// combined image-sampler. In MSL, this is used when a function parameter might hold</span>
<span class="w">    </span><span class="c1">// either a regular combined image-sampler or one that has an attached sampler</span>
<span class="w">    </span><span class="c1">// Y&#39;CbCr conversion.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationDynamicImageSampler</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Apply to a variable in the Input storage class; marks it as holding the size of the stage</span>
<span class="w">    </span><span class="c1">// input grid.</span>
<span class="w">    </span><span class="c1">// In MSL, this is used to hold the vertex and instance counts in a tessellation pipeline</span>
<span class="w">    </span><span class="c1">// vertex shader.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationBuiltInStageInputSize</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Apply to any access chain of a tessellation I/O variable; stores the type of the sub-object</span>
<span class="w">    </span><span class="c1">// that was chained to, as recorded in the input variable itself. This is used in case the pointer</span>
<span class="w">    </span><span class="c1">// is itself used as the base of an access chain, to calculate the original type of the sub-object</span>
<span class="w">    </span><span class="c1">// chained to, in case a swizzle needs to be applied. This should not happen normally with valid</span>
<span class="w">    </span><span class="c1">// SPIR-V, but the MSL backend can change the type of input variables, necessitating the</span>
<span class="w">    </span><span class="c1">// addition of swizzles to keep the generated code compiling.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationTessIOOriginalInputTypeID</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Apply to any access chain of an interface variable used with pull-model interpolation, where the variable is a</span>
<span class="w">    </span><span class="c1">// vector but the resulting pointer is a scalar; stores the component index that is to be accessed by the chain.</span>
<span class="w">    </span><span class="c1">// This is used when emitting calls to interpolation functions on the chain in MSL: in this case, the component</span>
<span class="w">    </span><span class="c1">// must be applied to the result, since pull-model interpolants in MSL cannot be swizzled directly, but the</span>
<span class="w">    </span><span class="c1">// results of interpolation can.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationInterpolantComponentExpr</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Apply to any struct type that is used in the Workgroup storage class.</span>
<span class="w">    </span><span class="c1">// This causes matrices in MSL prior to Metal 3.0 to be emitted using a special</span>
<span class="w">    </span><span class="c1">// class that is convertible to the standard matrix type, to work around the</span>
<span class="w">    </span><span class="c1">// lack of constructors in the &#39;threadgroup&#39; address space.</span>
<span class="w">    </span><span class="n">SPIRVCrossDecorationWorkgroupStruct</span><span class="p">,</span>

<span class="w">    </span><span class="n">SPIRVCrossDecorationOverlappingBinding</span><span class="p">,</span>

<span class="w">    </span><span class="n">SPIRVCrossDecorationCount</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">Meta</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Decoration</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">alias</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">qualified_alias</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">hlsl_semantic</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">user_type</span><span class="p">;</span>
<span class="w">        </span><span class="n">Bitset</span><span class="w"> </span><span class="n">decoration_flags</span><span class="p">;</span>
<span class="w">        </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltInMax</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">xfb_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">xfb_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">stream</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">array_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">matrix_stride</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">input_attachment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">spec_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="n">spv</span><span class="o">::</span><span class="n">FPRoundingMode</span><span class="w"> </span><span class="n">fp_rounding_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">FPRoundingModeMax</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">builtin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">qualified_alias_explicit_override</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">Extended</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Extended</span><span class="p">()</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// MSVC 2013 workaround to init like this.</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">v</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">values</span><span class="p">)</span>
<span class="w">                    </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">Bitset</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">values</span><span class="p">[</span><span class="n">SPIRVCrossDecorationCount</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">extended</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Intentionally not a SmallVector. Decoration is large and somewhat rare.</span>
<span class="w">    </span><span class="n">Vector</span><span class="o">&lt;</span><span class="n">Decoration</span><span class="o">&gt;</span><span class="w"> </span><span class="n">members</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">decoration_word_offset</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// For SPV_GOOGLE_hlsl_functionality1.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">hlsl_is_magic_counter_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// ID for the sibling counter buffer.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">hlsl_magic_counter_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// A user callback that remaps the type of any variable.</span>
<span class="c1">// var_name is the declared name of the variable.</span>
<span class="c1">// name_of_type is the textual name of the type which will be used in the code unless written to by the callback.</span>
<span class="k">using</span><span class="w"> </span><span class="n">VariableTypeRemapCallback</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_name</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name_of_type</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Hasher</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">u32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">h</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x100000001b3ull</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xcbf29ce484222325ull</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_floating_point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Half</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Float</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Double</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_integral</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">SByte</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UByte</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Short</span><span class="w"> </span><span class="o">||</span>
<span class="w">           </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UShort</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Int</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UInt</span><span class="w"> </span><span class="o">||</span>
<span class="w">           </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Int64</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">type</span><span class="p">.</span><span class="n">basetype</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UInt64</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="nf">to_signed_basetype</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">8</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">SByte</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">16</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Short</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">32</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Int</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">64</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Int64</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;Invalid bit width.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="nf">to_unsigned_basetype</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">8</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UByte</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">16</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UShort</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">32</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UInt</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">64</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">UInt64</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;Invalid bit width.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Returns true if an arithmetic operation does not change behavior depending on signedness.</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">opcode_is_sign_invariant</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpIEqual</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpINotEqual</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpISub</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpIAdd</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpIMul</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpShiftLeftLogical</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpBitwiseOr</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpBitwiseXor</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpBitwiseAnd</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">opcode_can_promote_integer_implicitly</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">opcode</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpSNegate</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpNot</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpBitwiseAnd</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpBitwiseOr</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpBitwiseXor</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpShiftLeftLogical</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpShiftRightLogical</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpShiftRightArithmetic</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpIAdd</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpISub</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpIMul</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpSDiv</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpUDiv</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpSRem</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpUMod</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="no">spv</span><span class="o">::</span><span class="no">OpSMod</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SetBindingPair</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">;</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SetBindingPair</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">desc_set</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">desc_set</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">binding</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SetBindingPair</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">desc_set</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">desc_set</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">desc_set</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">desc_set</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">binding</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">LocationComponentPair</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">component</span><span class="p">;</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LocationComponentPair</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">location</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">component</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">LocationComponentPair</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">location</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">location</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">component</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">StageSetBinding</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">;</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">StageSetBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">model</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">desc_set</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">desc_set</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">binding</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">InternalHasher</span>
<span class="p">{</span>
<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">SetBindingPair</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Quality of hash doesn&#39;t really matter here.</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">hash_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">.</span><span class="n">desc_set</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">hash_binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">.</span><span class="n">binding</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">hash_set</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x10001b31</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">hash_binding</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">LocationComponentPair</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Quality of hash doesn&#39;t really matter here.</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">hash_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">.</span><span class="n">location</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">hash_binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">.</span><span class="n">component</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">hash_set</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x10001b31</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">hash_binding</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">StageSetBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Quality of hash doesn&#39;t really matter here.</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">hash_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">.</span><span class="n">model</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">hash_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">.</span><span class="n">desc_set</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="n">tmp_hash</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">hash_model</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x10001b31</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">hash_set</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">tmp_hash</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mh">0x10001b31</span><span class="p">)</span><span class="w"> </span><span class="o">^</span><span class="w"> </span><span class="n">value</span><span class="p">.</span><span class="n">binding</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Special constant used in a {MSL,HLSL}ResourceBinding desc_set</span>
<span class="c1">// element to indicate the bindings for the push constants.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ResourceBindingPushConstantDescriptorSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">0u</span><span class="p">);</span>

<span class="c1">// Special constant used in a {MSL,HLSL}ResourceBinding binding</span>
<span class="c1">// element to indicate the bindings for the push constants.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ResourceBindingPushConstantBinding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace SPIRV_CROSS_NAMESPACE</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">std</span>
<span class="p">{</span>
<span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="n">SPIRV_CROSS_NAMESPACE</span><span class="o">::</span><span class="n">Types</span><span class="w"> </span><span class="n">type</span><span class="o">&gt;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">hash</span><span class="o">&lt;</span><span class="n">SPIRV_CROSS_NAMESPACE</span><span class="o">::</span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRV_CROSS_NAMESPACE</span><span class="o">::</span><span class="n">TypedID</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">value</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace std</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 - 2023 Intel Corporation.
This software and the related documents are Intel copyrighted materials, and your
use of them is governed by the express license under which they were provided to
you (License). Unless the License provides otherwise, you may not use, modify, copy,
publish, distribute, disclose or transmit this software or the related documents
without Intel&#39;s prior written permission.
This software and the related documents are provided as is, with no express or implied
warranties, other than those that are expressly stated in the License..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>