<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File spirv_msl.hpp &mdash; Intel® GPA Framework  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/gpa.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
     
    <script type="text/javascript">
        //configure tms    
        var wapLocalCode = 'us_en'; //dynamically set per localized site, see mapping table for values
        var wapSection = "gpa-sdk";
        //load tms
        (function() {
            var host = (window.document.location.protocol == 'http:') ? "http://www.intel.com" : "https://www.intel.com";
            var url = host+"/content/dam/www/global/wap/tms-loader.js"; //wap file url
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;  po.src = url;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
    </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

    <form action="https://software.intel.com/en-us/gpa" method="get" target="_blank">
        <button class="download-button" type="submit">Free Download</button>
    </form>
    

          
          
          <a href="../index.html">
            
              <img src="../_static/logo-classicblue-3000px.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../src/getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#layer-framework-primer">Layer Framework Primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#capture-a-stream">Capture a Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#play-back-stream">Play Back Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#stack-multiple-layers">Stack Multiple Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/guides.html">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/guides/extending_test_layer.html">Extending &quot;Helloworld&quot; Simple Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#layer-anatomy">Layer Anatomy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#api-call-routing">API Call Routing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/reference.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-injector">gpa-injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-player">gpa-player</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-subcapture-recorder">gpa-subcapture-recorder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-info">gpa-stream-info</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-analyzer">gpa-stream-analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-cpp-generator">gpa-cpp-generator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-help">gpa-help</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-metrics-collector">gpa-metrics-collector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-system-info">gpa-system-info</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/layers.html">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#capture">capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#screenshot">screenshot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#hud-layer">hud-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#logging">logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#api-debug-layer">api-debug-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#device-override">device-override</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-resources-layer">dump-resources-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-state-layer">dump-state-layer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/python.html">Python Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html">C++ Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#page-hierarchy">Page Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#class-hierarchy">Class Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#file-hierarchy">File Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#full-api">Full API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#namespaces">Namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#classes-and-structs">Classes and Structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#unions">Unions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#variables">Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#defines">Defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#typedefs">Typedefs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/features.html">Features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#capture-and-playback">Capture and Playback</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#basic-capture-and-playback">Basic Capture and Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#deferred-capture">Deferred Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#range-repeat">Range Repeat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#subcapture">Subcapture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#stream-analysis">Stream Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metric-collection">Metric Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#experiments">Experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metadata-extraction">Metadata Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#resource-extraction">Resource Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-call-inspection">API Call Inspection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#layers">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#heads-up-display-hud-layer">Heads-Up Display(HUD) Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#screenshot-layer">Screenshot Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#logging-layer">Logging Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-debug-layer">Api Debug Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#device-override-layer">Device Override Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#custom-user-layers">Custom (User) Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/requirements.html">System Requirements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#hardware-requirements">Hardware Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#software-requirements">Software Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#supported-graphics-apis">Supported Graphics APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#id2">2024.3 (09/12/2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#new">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#changed">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#fixed">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-13-2024">2024.2 (June 13 2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id3">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id4">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id5">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-15-2024">2024.1 (March 15 2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id6">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id7">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id8">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#dec-14-2023">2023.4 (Dec 14 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id9">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id10">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id11">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#sept-21-2023">2023.3 (Sept 21 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id12">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id13">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id14">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2023">2023.2 (15 June 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id15">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id16">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id17">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2023">2023.1 (15 March 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id18">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id19">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id20">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2022">2022.4 (15 December 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id21">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id22">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id23">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#deprecated">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2022">2022.3 (15 September 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id24">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id25">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id26">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2022">2022.2 (30 June 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id27">New</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2022">2022.1 (16 March 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id28">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id29">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id30">Changed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2021">2021.4 (16 December 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id31">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id32">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id33">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2021">2021.3 (23 September 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id34">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id35">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id36">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2021">2021.2 (24 June 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id37">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id38">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id39">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2021">2021.1 (24 March 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id40">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id41">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id42">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#january-2021">2020.4.1 (21 January 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id43">NEW</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2020">2020.4 (14 December 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id44">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id45">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id46">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2020">2020.3 (24 September 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id47">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id48">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id49">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2020">2020.2 (25 June 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id50">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id53">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id54">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2020">2020.1 (26 March 2020)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2019">2019.4 (19 December 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2019">2019.3 (26 September 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2019">2019.2 (27 June 2019)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#known-issues-and-limitations">Known Issues and Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id2">2024.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id5">2024.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id10">2024.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id15">2023.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id20">2023.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id23">2023.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id26">2023.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id29">2022.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id30">2022.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id31">2022.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id32">2022.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id33">2021.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id34">2021.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id35">2021.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id36">2020.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id37">2019.2</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/licenses.html">Legal Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/licenses.html#third-party-content">Third Party Content</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/disclaimer.html">Notices &amp; Disclaimers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Intel® GPA Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File spirv_msl.hpp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-spirv-msl-hpp">
<span id="program-listing-file-include-spirv-cross-spirv-msl-hpp"></span><h1>Program Listing for File spirv_msl.hpp<a class="headerlink" href="#program-listing-for-file-spirv-msl-hpp" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file_include_spirv_cross_spirv_msl.hpp.html#file-include-spirv-cross-spirv-msl-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">include\spirv_cross\spirv_msl.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright 2016-2021 The Brenwill Workshop Ltd.</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0 OR MIT</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * At your option, you may choose to accept this material under either:</span>
<span class="cm"> *  1. The Apache License, Version 2.0, found at &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;, or</span>
<span class="cm"> *  2. The MIT License, found at &lt;http://opensource.org/licenses/MIT&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef SPIRV_CROSS_MSL_HPP</span>
<span class="cp">#define SPIRV_CROSS_MSL_HPP</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv_glsl.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stddef.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_set&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">SPIRV_CROSS_NAMESPACE</span>
<span class="p">{</span>

<span class="c1">// Indicates the format of a shader interface variable. Currently limited to specifying</span>
<span class="c1">// if the input is an 8-bit unsigned integer, 16-bit unsigned integer, or</span>
<span class="c1">// some other format.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">MSLShaderVariableFormat</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_OTHER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_UINT8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_UINT16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_ANY16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_ANY32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Deprecated aliases.</span>
<span class="w">    </span><span class="n">MSL_VERTEX_FORMAT_OTHER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_OTHER</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_VERTEX_FORMAT_UINT8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_UINT8</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_VERTEX_FORMAT_UINT16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_UINT16</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_INPUT_FORMAT_OTHER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_OTHER</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_INPUT_FORMAT_UINT8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_UINT8</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_INPUT_FORMAT_UINT16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_UINT16</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_INPUT_FORMAT_ANY16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_ANY16</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_INPUT_FORMAT_ANY32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_ANY32</span><span class="p">,</span>

<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="c1">// Indicates the rate at which a variable changes value, one of: per-vertex,</span>
<span class="c1">// per-primitive, or per-patch.</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">MSLShaderVariableRate</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_RATE_PER_VERTEX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_RATE_PER_PRIMITIVE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_RATE_PER_PATCH</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>

<span class="w">    </span><span class="n">MSL_SHADER_VARIABLE_RATE_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span><span class="p">,</span>
<span class="p">};</span>

<span class="c1">// Defines MSL characteristics of a shader interface variable at a particular location.</span>
<span class="c1">// After compilation, it is possible to query whether or not this location was used.</span>
<span class="c1">// If vecsize is nonzero, it must be greater than or equal to the vecsize declared in the shader,</span>
<span class="c1">// or behavior is undefined.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MSLShaderInterfaceVariable</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">component</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLShaderVariableFormat</span><span class="w"> </span><span class="n">format</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_FORMAT_OTHER</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltInMax</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">vecsize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLShaderVariableRate</span><span class="w"> </span><span class="n">rate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SHADER_VARIABLE_RATE_PER_VERTEX</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Matches the binding index of a MSL resource for a binding within a descriptor set.</span>
<span class="c1">// Taken together, the stage, desc_set and binding combine to form a reference to a resource</span>
<span class="c1">// descriptor used in a particular shading stage. The count field indicates the number of</span>
<span class="c1">// resources consumed by this binding, if the binding represents an array of resources.</span>
<span class="c1">// If the resource array is a run-time-sized array, which are legal in GLSL or SPIR-V, this value</span>
<span class="c1">// will be used to declare the array size in MSL, which does not support run-time-sized arrays.</span>
<span class="c1">// If pad_argument_buffer_resources is enabled, the base_type and count values are used to</span>
<span class="c1">// specify the base type and array size of the resource in the argument buffer, if that resource</span>
<span class="c1">// is not defined and used by the shader. With pad_argument_buffer_resources enabled, this</span>
<span class="c1">// information will be used to pad the argument buffer structure, in order to align that</span>
<span class="c1">// structure consistently for all uses, across all shaders, of the descriptor set represented</span>
<span class="c1">// by the arugment buffer. If pad_argument_buffer_resources is disabled, base_type does not</span>
<span class="c1">// need to be populated, and if the resource is also not a run-time sized array, the count</span>
<span class="c1">// field does not need to be populated.</span>
<span class="c1">// If using MSL 2.0 argument buffers, the descriptor set is not marked as a discrete descriptor set,</span>
<span class="c1">// and (for iOS only) the resource is not a storage image (sampled != 2), the binding reference we</span>
<span class="c1">// remap to will become an [[id(N)]] attribute within the &quot;descriptor set&quot; argument buffer structure.</span>
<span class="c1">// For resources which are bound in the &quot;classic&quot; MSL 1.0 way or discrete descriptors, the remap will</span>
<span class="c1">// become a [[buffer(N)]], [[texture(N)]] or [[sampler(N)]] depending on the resource types used.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">MSLResourceBinding</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">stage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModelMax</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">basetype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Unknown</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">msl_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">msl_texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">msl_sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerCoord</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COORD_NORMALIZED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COORD_PIXEL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerFilter</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_FILTER_NEAREST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_FILTER_LINEAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_FILTER_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerMipFilter</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_MIP_FILTER_NONE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_MIP_FILTER_NEAREST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_MIP_FILTER_LINEAR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_MIP_FILTER_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerAddress</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_ADDRESS_CLAMP_TO_ZERO</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_ADDRESS_CLAMP_TO_EDGE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_ADDRESS_CLAMP_TO_BORDER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_ADDRESS_REPEAT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_ADDRESS_MIRRORED_REPEAT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_ADDRESS_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerCompareFunc</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_NEVER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_LESS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_LESS_EQUAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_GREATER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_GREATER_EQUAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_EQUAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_NOT_EQUAL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_ALWAYS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerBorderColor</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_BORDER_COLOR_TRANSPARENT_BLACK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_BORDER_COLOR_OPAQUE_BLACK</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_BORDER_COLOR_OPAQUE_WHITE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_BORDER_COLOR_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLFormatResolution</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_FORMAT_RESOLUTION_444</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_FORMAT_RESOLUTION_422</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_FORMAT_RESOLUTION_420</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_FORMAT_RESOLUTION_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLChromaLocation</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_CHROMA_LOCATION_COSITED_EVEN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_CHROMA_LOCATION_MIDPOINT</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_CHROMA_LOCATION_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLComponentSwizzle</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_IDENTITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_ZERO</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_ONE</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_R</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_G</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_B</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_A</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_COMPONENT_SWIZZLE_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerYCbCrModelConversion</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_BT_709</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_BT_601</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_BT_2020</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_MODEL_CONVERSION_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">MSLSamplerYCbCrRange</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_RANGE_ITU_FULL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_RANGE_ITU_NARROW</span><span class="p">,</span>
<span class="w">    </span><span class="n">MSL_SAMPLER_YCBCR_RANGE_INT_MAX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">MSLConstexprSampler</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MSLSamplerCoord</span><span class="w"> </span><span class="n">coord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_COORD_NORMALIZED</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerFilter</span><span class="w"> </span><span class="n">min_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_FILTER_NEAREST</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerFilter</span><span class="w"> </span><span class="n">mag_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_FILTER_NEAREST</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerMipFilter</span><span class="w"> </span><span class="n">mip_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_MIP_FILTER_NONE</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerAddress</span><span class="w"> </span><span class="n">s_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_ADDRESS_CLAMP_TO_EDGE</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerAddress</span><span class="w"> </span><span class="n">t_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_ADDRESS_CLAMP_TO_EDGE</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerAddress</span><span class="w"> </span><span class="n">r_address</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_ADDRESS_CLAMP_TO_EDGE</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerCompareFunc</span><span class="w"> </span><span class="n">compare_func</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_COMPARE_FUNC_NEVER</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerBorderColor</span><span class="w"> </span><span class="n">border_color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_BORDER_COLOR_TRANSPARENT_BLACK</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lod_clamp_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">lod_clamp_max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1000.0f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">max_anisotropy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sampler Y&#39;CbCr conversion parameters</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">planes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLFormatResolution</span><span class="w"> </span><span class="n">resolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_FORMAT_RESOLUTION_444</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerFilter</span><span class="w"> </span><span class="n">chroma_filter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_FILTER_NEAREST</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLChromaLocation</span><span class="w"> </span><span class="n">x_chroma_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_CHROMA_LOCATION_COSITED_EVEN</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLChromaLocation</span><span class="w"> </span><span class="n">y_chroma_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_CHROMA_LOCATION_COSITED_EVEN</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLComponentSwizzle</span><span class="w"> </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span><span class="w"> </span><span class="c1">// IDENTITY, IDENTITY, IDENTITY, IDENTITY</span>
<span class="w">    </span><span class="n">MSLSamplerYCbCrModelConversion</span><span class="w"> </span><span class="n">ycbcr_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY</span><span class="p">;</span>
<span class="w">    </span><span class="n">MSLSamplerYCbCrRange</span><span class="w"> </span><span class="n">ycbcr_range</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_SAMPLER_YCBCR_RANGE_ITU_FULL</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">bpc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">compare_enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">lod_clamp_enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">anisotropy_enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">ycbcr_conversion_enable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="n">MSLConstexprSampler</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="n">swizzle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_IDENTITY</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">swizzle_is_identity</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">swizzle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_IDENTITY</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_IDENTITY</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">                </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_IDENTITY</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_IDENTITY</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">swizzle_has_one_or_zero</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">swizzle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ZERO</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ONE</span><span class="w"> </span><span class="o">||</span>
<span class="w">                </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ZERO</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ONE</span><span class="w"> </span><span class="o">||</span>
<span class="w">                </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ZERO</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ONE</span><span class="w"> </span><span class="o">||</span>
<span class="w">                </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ZERO</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">swizzle</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">MSL_COMPONENT_SWIZZLE_ONE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Special constant used in a MSLResourceBinding desc_set</span>
<span class="c1">// element to indicate the bindings for the push constants.</span>
<span class="c1">// Kinda deprecated. Just use ResourceBindingPushConstant{DescriptorSet,Binding} directly.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">kPushConstDescSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ResourceBindingPushConstantDescriptorSet</span><span class="p">;</span>

<span class="c1">// Special constant used in a MSLResourceBinding binding</span>
<span class="c1">// element to indicate the bindings for the push constants.</span>
<span class="c1">// Kinda deprecated. Just use ResourceBindingPushConstant{DescriptorSet,Binding} directly.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">kPushConstBinding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ResourceBindingPushConstantBinding</span><span class="p">;</span>

<span class="c1">// Special constant used in a MSLResourceBinding binding</span>
<span class="c1">// element to indicate the buffer binding for swizzle buffers.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">kSwizzleBufferBinding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">1u</span><span class="p">);</span>

<span class="c1">// Special constant used in a MSLResourceBinding binding</span>
<span class="c1">// element to indicate the buffer binding for buffer size buffers to support OpArrayLength.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">kBufferSizeBufferBinding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">2u</span><span class="p">);</span>

<span class="c1">// Special constant used in a MSLResourceBinding binding</span>
<span class="c1">// element to indicate the buffer binding used for the argument buffer itself.</span>
<span class="c1">// This buffer binding should be kept as small as possible as all automatic bindings for buffers</span>
<span class="c1">// will start at max(kArgumentBufferBinding) + 1.</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">kArgumentBufferBinding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">~</span><span class="p">(</span><span class="mi">3u</span><span class="p">);</span>

<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">kMaxArgumentBuffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>

<span class="c1">// Decompiles SPIR-V to Metal Shading Language</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CompilerMSL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">CompilerGLSL</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Options for compiling to Metal Shading Language</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Options</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">typedef</span><span class="w"> </span><span class="k">enum</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">iOS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">macOS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="n">Platform</span><span class="p">;</span>

<span class="w">        </span><span class="n">Platform</span><span class="w"> </span><span class="n">platform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">macOS</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">msl_version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_msl_version</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">texel_buffer_texture_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4096</span><span class="p">;</span><span class="w"> </span><span class="c1">// Width of 2D Metal textures used as 1D texel buffers</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">r32ui_linear_texture_alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">r32ui_alignment_constant_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">65535</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">swizzle_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">indirect_params_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">29</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_output_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">28</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_patch_output_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">27</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_tess_factor_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">26</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buffer_size_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">25</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">view_mask_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">24</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dynamic_offsets_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">23</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_input_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">22</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_index_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">21</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_patch_input_buffer_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_input_wg_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">device_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">enable_frag_output_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Metal doesn&#39;t allow setting a fixed sample mask directly in the pipeline.</span>
<span class="w">        </span><span class="c1">// We can evade this restriction by ANDing the internal sample_mask output</span>
<span class="w">        </span><span class="c1">// of the shader with the additional fixed sample mask.</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">additional_fixed_sample_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_point_size_builtin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_frag_depth_builtin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_frag_stencil_ref_builtin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">disable_rasterization</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">capture_output_to_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">swizzle_texture_samples</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">tess_domain_origin_lower_left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">multiview</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">multiview_layered_rendering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">view_index_from_device_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">dispatch_base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">texture_1D_as_2D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Enable use of Metal argument buffers.</span>
<span class="w">        </span><span class="c1">// MSL 2.0 must also be enabled.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">argument_buffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Defines Metal argument buffer tier levels.</span>
<span class="w">        </span><span class="c1">// Uses same values as Metal MTLArgumentBuffersTier enumeration.</span>
<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">ArgumentBuffersTier</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">Tier1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">Tier2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// When using Metal argument buffers, indicates the Metal argument buffer tier level supported by the Metal platform.</span>
<span class="w">        </span><span class="c1">// Ignored when Options::argument_buffers is disabled.</span>
<span class="w">        </span><span class="c1">// - Tier1 supports writable images on macOS, but not on iOS.</span>
<span class="w">        </span><span class="c1">// - Tier2 supports writable images on macOS and iOS, and higher resource count limits.</span>
<span class="w">        </span><span class="c1">// Tier capabilities based on recommendations from Apple engineering.</span>
<span class="w">        </span><span class="n">ArgumentBuffersTier</span><span class="w"> </span><span class="n">argument_buffers_tier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ArgumentBuffersTier</span><span class="o">::</span><span class="n">Tier1</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Enables specifick argument buffer format with extra information to track SSBO-length</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">runtime_array_rich_descriptor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Ensures vertex and instance indices start at zero. This reflects the behavior of HLSL with SV_VertexID and SV_InstanceID.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_base_index_zero</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Fragment output in MSL must have at least as many components as the render pass.</span>
<span class="w">        </span><span class="c1">// Add support to explicit pad out components.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">pad_fragment_output_components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Specifies whether the iOS target version supports the [[base_vertex]] and [[base_instance]] attributes.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">ios_support_base_vertex_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Use Metal&#39;s native frame-buffer fetch API for subpass inputs.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_framebuffer_fetch_subpasses</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Enables use of &quot;fma&quot; intrinsic for invariant float math</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">invariant_float_math</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Emulate texturecube_array with texture2d_array for iOS where this type is not available</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">emulate_cube_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Allow user to enable decoration binding</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_decoration_binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Requires MSL 2.1, use the native support for texel buffers.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">texture_buffer_native</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Forces all resources which are part of an argument buffer to be considered active.</span>
<span class="w">        </span><span class="c1">// This ensures ABI compatibility between shaders where some resources might be unused,</span>
<span class="w">        </span><span class="c1">// and would otherwise declare a different IAB.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_active_argument_buffer_resources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Aligns each resource in an argument buffer to its assigned index value, id(N),</span>
<span class="w">        </span><span class="c1">// by adding synthetic padding members in the argument buffer struct for any resources</span>
<span class="w">        </span><span class="c1">// in the argument buffer that are not defined and used by the shader. This allows</span>
<span class="w">        </span><span class="c1">// the shader to index into the correct argument in a descriptor set argument buffer</span>
<span class="w">        </span><span class="c1">// that is shared across shaders, where not all resources in the argument buffer are</span>
<span class="w">        </span><span class="c1">// defined in each shader. For this to work, an MSLResourceBinding must be provided for</span>
<span class="w">        </span><span class="c1">// all descriptors in any descriptor set held in an argument buffer in the shader, and</span>
<span class="w">        </span><span class="c1">// that MSLResourceBinding must have the basetype and count members populated correctly.</span>
<span class="w">        </span><span class="c1">// The implementation here assumes any inline blocks in the argument buffer is provided</span>
<span class="w">        </span><span class="c1">// in a Metal buffer, and doesn&#39;t take into consideration inline blocks that are</span>
<span class="w">        </span><span class="c1">// optionally embedded directly into the argument buffer via add_inline_uniform_block().</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">pad_argument_buffer_resources</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Forces the use of plain arrays, which works around certain driver bugs on certain versions</span>
<span class="w">        </span><span class="c1">// of Intel Macbooks. See https://github.com/KhronosGroup/SPIRV-Cross/issues/1210.</span>
<span class="w">        </span><span class="c1">// May reduce performance in scenarios where arrays are copied around as value-types.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_native_arrays</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If a shader writes clip distance, also emit user varyings which</span>
<span class="w">        </span><span class="c1">// can be read in subsequent stages.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_clip_distance_user_varying</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// In a tessellation control shader, assume that more than one patch can be processed in a</span>
<span class="w">        </span><span class="c1">// single workgroup. This requires changes to the way the InvocationId and PrimitiveId</span>
<span class="w">        </span><span class="c1">// builtins are processed, but should result in more efficient usage of the GPU.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">multi_patch_workgroup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Use storage buffers instead of vertex-style attributes for tessellation evaluation</span>
<span class="w">        </span><span class="c1">// input. This may require conversion of inputs in the generated post-tessellation</span>
<span class="w">        </span><span class="c1">// vertex shader, but allows the use of nested arrays.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">raw_buffer_tese_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, a vertex shader will be compiled as part of a tessellation pipeline.</span>
<span class="w">        </span><span class="c1">// It will be translated as a compute kernel, so it can use the global invocation ID</span>
<span class="w">        </span><span class="c1">// to index the output buffer.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">vertex_for_tessellation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Assume that SubpassData images have multiple layers. Layered input attachments</span>
<span class="w">        </span><span class="c1">// are addressed relative to the Layer output from the vertex pipeline. This option</span>
<span class="w">        </span><span class="c1">// has no effect with multiview, since all input attachments are assumed to be layered</span>
<span class="w">        </span><span class="c1">// and will be addressed using the current ViewIndex.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">arrayed_subpass_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Whether to use SIMD-group or quadgroup functions to implement group non-uniform</span>
<span class="w">        </span><span class="c1">// operations. Some GPUs on iOS do not support the SIMD-group functions, only the</span>
<span class="w">        </span><span class="c1">// quadgroup functions.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">ios_use_simdgroup_functions</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, the subgroup size will be assumed to be one, and subgroup-related</span>
<span class="w">        </span><span class="c1">// builtins and operations will be emitted accordingly. This mode is intended to</span>
<span class="w">        </span><span class="c1">// be used by MoltenVK on hardware/software configurations which do not provide</span>
<span class="w">        </span><span class="c1">// sufficient support for subgroups.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">emulate_subgroups</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If nonzero, a fixed subgroup size to assume. Metal, similarly to VK_EXT_subgroup_size_control,</span>
<span class="w">        </span><span class="c1">// allows the SIMD-group size (aka thread execution width) to vary depending on</span>
<span class="w">        </span><span class="c1">// register usage and requirements. In certain circumstances--for example, a pipeline</span>
<span class="w">        </span><span class="c1">// in MoltenVK without VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT--</span>
<span class="w">        </span><span class="c1">// this is undesirable. This fixes the value of the SubgroupSize builtin, instead of</span>
<span class="w">        </span><span class="c1">// mapping it to the Metal builtin [[thread_execution_width]]. If the thread</span>
<span class="w">        </span><span class="c1">// execution width is reduced, the extra invocations will appear to be inactive.</span>
<span class="w">        </span><span class="c1">// If zero, the SubgroupSize will be allowed to vary, and the builtin will be mapped</span>
<span class="w">        </span><span class="c1">// to the Metal [[thread_execution_width]] builtin.</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">fixed_subgroup_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">IndexType</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">None</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">            </span><span class="n">UInt16</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">            </span><span class="n">UInt32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="c1">// The type of index in the index buffer, if present. For a compute shader, Metal</span>
<span class="w">        </span><span class="c1">// requires specifying the indexing at pipeline creation, rather than at draw time</span>
<span class="w">        </span><span class="c1">// as with graphics pipelines. This means we must create three different pipelines,</span>
<span class="w">        </span><span class="c1">// for no indexing, 16-bit indices, and 32-bit indices. Each requires different</span>
<span class="w">        </span><span class="c1">// handling for the gl_VertexIndex builtin. We may as well, then, create three</span>
<span class="w">        </span><span class="c1">// different shaders for these three scenarios.</span>
<span class="w">        </span><span class="n">IndexType</span><span class="w"> </span><span class="n">vertex_index_type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IndexType</span><span class="o">::</span><span class="n">None</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, a dummy [[sample_id]] input is added to a fragment shader if none is present.</span>
<span class="w">        </span><span class="c1">// This will force the shader to run at sample rate, assuming Metal does not optimize</span>
<span class="w">        </span><span class="c1">// the extra threads away.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_sample_rate_shading</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, gl_HelperInvocation will be set manually whenever a fragment is discarded.</span>
<span class="w">        </span><span class="c1">// Some Metal devices have a bug where simd_is_helper_thread() does not return true</span>
<span class="w">        </span><span class="c1">// after a fragment has been discarded. This is a workaround that is only expected to be needed</span>
<span class="w">        </span><span class="c1">// until the bug is fixed in Metal; it is provided as an option to allow disabling it when that occurs.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">manual_helper_invocation_updates</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, extra checks will be emitted in fragment shaders to prevent writes</span>
<span class="w">        </span><span class="c1">// from discarded fragments. Some Metal devices have a bug where writes to storage resources</span>
<span class="w">        </span><span class="c1">// from discarded fragment threads continue to occur, despite the fragment being</span>
<span class="w">        </span><span class="c1">// discarded. This is a workaround that is only expected to be needed until the</span>
<span class="w">        </span><span class="c1">// bug is fixed in Metal; it is provided as an option so it can be enabled</span>
<span class="w">        </span><span class="c1">// only when the bug is present.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">check_discarded_frag_stores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, Lod operands to OpImageSample*DrefExplicitLod for 1D and 2D array images</span>
<span class="w">        </span><span class="c1">// will be implemented using a gradient instead of passing the level operand directly.</span>
<span class="w">        </span><span class="c1">// Some Metal devices have a bug where the level() argument to depth2d_array&lt;T&gt;::sample_compare()</span>
<span class="w">        </span><span class="c1">// in a fragment shader is biased by some unknown amount, possibly dependent on the</span>
<span class="w">        </span><span class="c1">// partial derivatives of the texture coordinates. This is a workaround that is only</span>
<span class="w">        </span><span class="c1">// expected to be needed until the bug is fixed in Metal; it is provided as an option</span>
<span class="w">        </span><span class="c1">// so it can be enabled only when the bug is present.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">sample_dref_lod_array_as_grad</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// MSL doesn&#39;t guarantee coherence between writes and subsequent reads of read_write textures.</span>
<span class="w">        </span><span class="c1">// This inserts fences before each read of a read_write texture to ensure coherency.</span>
<span class="w">        </span><span class="c1">// If you&#39;re sure you never rely on this, you can set this to false for a possible performance improvement.</span>
<span class="w">        </span><span class="c1">// Note: Only Apple&#39;s GPU compiler takes advantage of the lack of coherency, so make sure to test on Apple GPUs if you disable this.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">readwrite_texture_fences</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Metal 3.1 introduced a Metal regression bug which causes infinite recursion during</span>
<span class="w">        </span><span class="c1">// Metal&#39;s analysis of an entry point input structure that is itself recursive. Enabling</span>
<span class="w">        </span><span class="c1">// this option will replace the recursive input declaration with a alternate variable of</span>
<span class="w">        </span><span class="c1">// type void*, and then cast to the correct type at the top of the entry point function.</span>
<span class="w">        </span><span class="c1">// The bug has been reported to Apple, and will hopefully be fixed in future releases.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">replace_recursive_inputs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, manual fixups of gradient vectors for cube texture lookups will be performed.</span>
<span class="w">        </span><span class="c1">// All released Apple Silicon GPUs to date behave incorrectly when sampling a cube texture</span>
<span class="w">        </span><span class="c1">// with explicit gradients. They will ignore one of the three partial derivatives based</span>
<span class="w">        </span><span class="c1">// on the selected major axis, and expect the remaining derivatives to be partially</span>
<span class="w">        </span><span class="c1">// transformed.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">agx_manual_cube_grad_fixup</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Metal will discard fragments with side effects under certain circumstances prematurely.</span>
<span class="w">        </span><span class="c1">// Example: CTS test dEQP-VK.fragment_operations.early_fragment.discard_no_early_fragment_tests_depth</span>
<span class="w">        </span><span class="c1">// Test will render a full screen quad with varying depth [0,1] for each fragment.</span>
<span class="w">        </span><span class="c1">// Each fragment will do an operation with side effects, modify the depth value and</span>
<span class="w">        </span><span class="c1">// discard the fragment. The test expects the fragment to be run due to:</span>
<span class="w">        </span><span class="c1">// https://registry.khronos.org/vulkan/specs/1.0-extensions/html/vkspec.html#fragops-shader-depthreplacement</span>
<span class="w">        </span><span class="c1">// which states that the fragment shader must be run due to replacing the depth in shader.</span>
<span class="w">        </span><span class="c1">// However, Metal may prematurely discards fragments without executing them</span>
<span class="w">        </span><span class="c1">// (I believe this to be due to a greedy optimization on their end) making the test fail.</span>
<span class="w">        </span><span class="c1">// This option enforces fragment execution for such cases where the fragment has operations</span>
<span class="w">        </span><span class="c1">// with side effects. Provided as an option hoping Metal will fix this issue in the future.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_fragment_with_side_effects_execution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If set, adds a depth pass through statement to circumvent the following issue:</span>
<span class="w">        </span><span class="c1">// When the same depth/stencil is used as input and depth/stencil attachment, we need to</span>
<span class="w">        </span><span class="c1">// force Metal to perform the depth/stencil write after fragment execution. Otherwise,</span>
<span class="w">        </span><span class="c1">// Metal will write to the depth attachment before fragment execution. This happens</span>
<span class="w">        </span><span class="c1">// if the fragment does not modify the depth value.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">input_attachment_is_ds_attachment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_ios</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">platform</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">iOS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_macos</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">platform</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">macOS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">use_quadgroup_operation</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">is_ios</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">ios_use_simdgroup_functions</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_msl_version</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">minor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">patch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">msl_version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_msl_version</span><span class="p">(</span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="n">minor</span><span class="p">,</span><span class="w"> </span><span class="n">patch</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">supports_msl_version</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">minor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">patch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">msl_version</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">make_msl_version</span><span class="p">(</span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="n">minor</span><span class="p">,</span><span class="w"> </span><span class="n">patch</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">make_msl_version</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">minor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">patch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">major</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">10000</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">minor</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">patch</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Options</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_msl_options</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">msl_options</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_msl_options</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Options</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">msl_options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opts</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow runtime to disable pipeline</span>
<span class="w">    </span><span class="c1">// rasterization if vertex shader requires rasterization to be disabled.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">get_is_rasterization_disabled</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">is_rasterization_disabled</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">get_entry_point</span><span class="p">().</span><span class="n">model</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModelVertex</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                             </span><span class="n">get_entry_point</span><span class="p">().</span><span class="n">model</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModelTessellationControl</span><span class="w"> </span><span class="o">||</span>
<span class="w">                                             </span><span class="n">get_entry_point</span><span class="p">().</span><span class="n">model</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModelTessellationEvaluation</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow it to pass an auxiliary</span>
<span class="w">    </span><span class="c1">// swizzle buffer if the shader needs it.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_swizzle_buffer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">used_swizzle_buffer</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow it to pass a buffer</span>
<span class="w">    </span><span class="c1">// containing STORAGE_BUFFER buffer sizes to support OpArrayLength.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_buffer_size_buffer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="n">buffers_requiring_array_length</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">buffer_requires_array_length</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">buffers_requiring_array_length</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow it to pass a buffer</span>
<span class="w">    </span><span class="c1">// containing the view mask for the current multiview subpass.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_view_mask_buffer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">msl_options</span><span class="p">.</span><span class="n">multiview</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">msl_options</span><span class="p">.</span><span class="n">view_index_from_device_index</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow it to pass a buffer</span>
<span class="w">    </span><span class="c1">// containing the dispatch base workgroup ID.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_dispatch_base_buffer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">msl_options</span><span class="p">.</span><span class="n">dispatch_base</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">msl_options</span><span class="p">.</span><span class="n">supports_msl_version</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow it to pass an output</span>
<span class="w">    </span><span class="c1">// buffer if the shader needs it.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_output_buffer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">capture_output_to_buffer</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">stage_out_var_id</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ID</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow it to pass a patch output</span>
<span class="w">    </span><span class="c1">// buffer if the shader needs it.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_patch_output_buffer</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">capture_output_to_buffer</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">patch_stage_out_var_id</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ID</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Provide feedback to calling API to allow it to pass an input threadgroup</span>
<span class="w">    </span><span class="c1">// buffer if the shader needs it.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_input_threadgroup_mem</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">capture_output_to_buffer</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">stage_in_var_id</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ID</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerMSL</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spirv</span><span class="p">);</span>
<span class="w">    </span><span class="n">CompilerMSL</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ir</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">word_count</span><span class="p">);</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerMSL</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ir</span><span class="p">);</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerMSL</span><span class="p">(</span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">ir</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// input is a shader interface variable description used to fix up shader input variables.</span>
<span class="w">    </span><span class="c1">// If shader inputs are provided, is_msl_shader_input_used() will return true after</span>
<span class="w">    </span><span class="c1">// calling ::compile() if the location were used by the MSL code.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_msl_shader_input</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MSLShaderInterfaceVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">input</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// output is a shader interface variable description used to fix up shader output variables.</span>
<span class="w">    </span><span class="c1">// If shader outputs are provided, is_msl_shader_output_used() will return true after</span>
<span class="w">    </span><span class="c1">// calling ::compile() if the location were used by the MSL code.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_msl_shader_output</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MSLShaderInterfaceVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">output</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// resource is a resource binding to indicate the MSL buffer,</span>
<span class="w">    </span><span class="c1">// texture or sampler index to use for a particular SPIR-V description set</span>
<span class="w">    </span><span class="c1">// and binding. If resource bindings are provided,</span>
<span class="w">    </span><span class="c1">// is_msl_resource_binding_used() will return true after calling ::compile() if</span>
<span class="w">    </span><span class="c1">// the set/binding combination was used by the MSL code.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_msl_resource_binding</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">MSLResourceBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resource</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// desc_set and binding are the SPIR-V descriptor set and binding of a buffer resource</span>
<span class="w">    </span><span class="c1">// in this shader. index is the index within the dynamic offset buffer to use. This</span>
<span class="w">    </span><span class="c1">// function marks that resource as using a dynamic offset (VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC</span>
<span class="w">    </span><span class="c1">// or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC). This function only has any effect if argument buffers</span>
<span class="w">    </span><span class="c1">// are enabled. If so, the buffer will have its address adjusted at the beginning of the shader with</span>
<span class="w">    </span><span class="c1">// an offset taken from the dynamic offset buffer.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_dynamic_buffer</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// desc_set and binding are the SPIR-V descriptor set and binding of a buffer resource</span>
<span class="w">    </span><span class="c1">// in this shader. This function marks that resource as an inline uniform block</span>
<span class="w">    </span><span class="c1">// (VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT). This function only has any effect if argument buffers</span>
<span class="w">    </span><span class="c1">// are enabled. If so, the buffer block will be directly embedded into the argument</span>
<span class="w">    </span><span class="c1">// buffer, instead of being referenced indirectly via pointer.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_inline_uniform_block</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// When using MSL argument buffers, we can force &quot;classic&quot; MSL 1.0 binding schemes for certain descriptor sets.</span>
<span class="w">    </span><span class="c1">// This corresponds to VK_KHR_push_descriptor in Vulkan.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_discrete_descriptor_set</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// If an argument buffer is large enough, it may need to be in the device storage space rather than</span>
<span class="w">    </span><span class="c1">// constant. Opt-in to this behavior here on a per set basis.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_argument_buffer_device_address_space</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">device_storage</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Query after compilation is done. This allows you to check if an input location was used by the shader.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_msl_shader_input_used</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Query after compilation is done. This allows you to check if an output location were used by the shader.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_msl_shader_output_used</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// If not using add_msl_shader_input, it&#39;s possible</span>
<span class="w">    </span><span class="c1">// that certain builtin attributes need to be automatically assigned locations.</span>
<span class="w">    </span><span class="c1">// This is typical for tessellation builtin inputs such as tess levels, gl_Position, etc.</span>
<span class="w">    </span><span class="c1">// This returns k_unknown_location if the location was explicitly assigned with</span>
<span class="w">    </span><span class="c1">// add_msl_shader_input or the builtin is not used, otherwise returns N in [[attribute(N)]].</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_automatic_builtin_input_location</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If not using add_msl_shader_output, it&#39;s possible</span>
<span class="w">    </span><span class="c1">// that certain builtin attributes need to be automatically assigned locations.</span>
<span class="w">    </span><span class="c1">// This is typical for tessellation builtin outputs such as tess levels, gl_Position, etc.</span>
<span class="w">    </span><span class="c1">// This returns k_unknown_location if the location were explicitly assigned with</span>
<span class="w">    </span><span class="c1">// add_msl_shader_output or the builtin were not used, otherwise returns N in [[attribute(N)]].</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_automatic_builtin_output_location</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// NOTE: Only resources which are remapped using add_msl_resource_binding will be reported here.</span>
<span class="w">    </span><span class="c1">// Constexpr samplers are always assumed to be emitted.</span>
<span class="w">    </span><span class="c1">// No specific MSLResourceBinding remapping is required for constexpr samplers as long as they are remapped</span>
<span class="w">    </span><span class="c1">// by remap_constexpr_sampler(_by_binding).</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_msl_resource_binding_used</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// This must only be called after a successful call to CompilerMSL::compile().</span>
<span class="w">    </span><span class="c1">// For a variable resource ID obtained through reflection API, report the automatically assigned resource index.</span>
<span class="w">    </span><span class="c1">// If the descriptor set was part of an argument buffer, report the [[id(N)]],</span>
<span class="w">    </span><span class="c1">// or [[buffer/texture/sampler]] binding for other resources.</span>
<span class="w">    </span><span class="c1">// If the resource was a combined image sampler, report the image binding here,</span>
<span class="w">    </span><span class="c1">// use the _secondary version of this call to query the sampler half of the resource.</span>
<span class="w">    </span><span class="c1">// If no binding exists, uint32_t(-1) is returned.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_automatic_msl_resource_binding</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Same as get_automatic_msl_resource_binding, but should only be used for combined image samplers, in which case the</span>
<span class="w">    </span><span class="c1">// sampler&#39;s binding is returned instead. For any other resource type, -1 is returned.</span>
<span class="w">    </span><span class="c1">// Secondary bindings are also used for the auxillary image atomic buffer.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_automatic_msl_resource_binding_secondary</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Same as get_automatic_msl_resource_binding, but should only be used for combined image samplers for multiplanar images,</span>
<span class="w">    </span><span class="c1">// in which case the second plane&#39;s binding is returned instead. For any other resource type, -1 is returned.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_automatic_msl_resource_binding_tertiary</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Same as get_automatic_msl_resource_binding, but should only be used for combined image samplers for triplanar images,</span>
<span class="w">    </span><span class="c1">// in which case the third plane&#39;s binding is returned instead. For any other resource type, -1 is returned.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_automatic_msl_resource_binding_quaternary</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Compiles the SPIR-V code into Metal Shading Language.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">compile</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Remap a sampler with ID to a constexpr sampler.</span>
<span class="w">    </span><span class="c1">// Older iOS targets must use constexpr samplers in certain cases (PCF),</span>
<span class="w">    </span><span class="c1">// so a static sampler must be used.</span>
<span class="w">    </span><span class="c1">// The sampler will not consume a binding, but be declared in the entry point as a constexpr sampler.</span>
<span class="w">    </span><span class="c1">// This can be used on both combined image/samplers (sampler2D) or standalone samplers.</span>
<span class="w">    </span><span class="c1">// The remapped sampler must not be an array of samplers.</span>
<span class="w">    </span><span class="c1">// Prefer remap_constexpr_sampler_by_binding unless you&#39;re also doing reflection anyways.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remap_constexpr_sampler</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MSLConstexprSampler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sampler</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Same as remap_constexpr_sampler, except you provide set/binding, rather than variable ID.</span>
<span class="w">    </span><span class="c1">// Remaps based on ID take priority over set/binding remaps.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remap_constexpr_sampler_by_binding</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">MSLConstexprSampler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">sampler</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// If using CompilerMSL::Options::pad_fragment_output_components, override the number of components we expect</span>
<span class="w">    </span><span class="c1">// to use for a particular location. The default is 4 if number of components is not overridden.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_fragment_output_components</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">components</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_combined_sampler_suffix</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">suffix</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">get_combined_sampler_suffix</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// An enum of SPIR-V functions that are implemented in additional</span>
<span class="w">    </span><span class="c1">// source code that is added to the shader if necessary.</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">SPVFuncImpl</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="kt">uint8_t</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">SPVFuncImplNone</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplMod</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplRadians</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplDegrees</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplFindILsb</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplFindSMsb</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplFindUMsb</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSSign</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplArrayCopy</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplArrayCopyMultidim</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplTexelBufferCoords</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplImage2DAtomicCoords</span><span class="p">,</span><span class="w"> </span><span class="c1">// Emulate texture2D atomic operations</span>
<span class="w">        </span><span class="n">SPVFuncImplGradientCube</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplFMul</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplFAdd</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplFSub</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplQuantizeToF16</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplCubemapTo2DArrayFace</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplUnsafeArray</span><span class="p">,</span><span class="w"> </span><span class="c1">// Allow Metal to use the array&lt;T&gt; template to make arrays a value type</span>
<span class="w">        </span><span class="n">SPVFuncImplStorageMatrix</span><span class="p">,</span><span class="w"> </span><span class="c1">// Allow threadgroup construction of matrices</span>
<span class="w">        </span><span class="n">SPVFuncImplInverse4x4</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplInverse3x3</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplInverse2x2</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// It is very important that this come before *Swizzle and ChromaReconstruct*, to ensure it&#39;s</span>
<span class="w">        </span><span class="c1">// emitted before them.</span>
<span class="w">        </span><span class="n">SPVFuncImplForwardArgs</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// Likewise, this must come before *Swizzle.</span>
<span class="w">        </span><span class="n">SPVFuncImplGetSwizzle</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplTextureSwizzle</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplGatherSwizzle</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplGatherCompareSwizzle</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplGatherConstOffsets</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplGatherCompareConstOffsets</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupBroadcast</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupBroadcastFirst</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupBallot</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupBallotBitExtract</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupBallotFindLSB</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupBallotFindMSB</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupBallotBitCount</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupAllEqual</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupShuffle</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupShuffleXor</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupShuffleUp</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplSubgroupShuffleDown</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplQuadBroadcast</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplQuadSwap</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplReflectScalar</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplRefractScalar</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplFaceForwardScalar</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructNearest2Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructNearest3Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear422CositedEven2Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear422CositedEven3Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear422Midpoint2Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear422Midpoint3Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XCositedEvenYCositedEven2Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XCositedEvenYCositedEven3Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XMidpointYCositedEven2Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XMidpointYCositedEven3Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XCositedEvenYMidpoint2Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XCositedEvenYMidpoint3Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XMidpointYMidpoint2Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplChromaReconstructLinear420XMidpointYMidpoint3Plane</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplExpandITUFullRange</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplExpandITUNarrowRange</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplConvertYCbCrBT709</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplConvertYCbCrBT601</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplConvertYCbCrBT2020</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplDynamicImageSampler</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplRayQueryIntersectionParams</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplVariableDescriptor</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplVariableSizedDescriptor</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplVariableDescriptorArray</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplPaddedStd140</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplReduceAdd</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplImageFence</span><span class="p">,</span>
<span class="w">        </span><span class="n">SPVFuncImplTextureCast</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// If the underlying resource has been used for comparison then duplicate loads of that resource must be too</span>
<span class="w">    </span><span class="c1">// Use Metal&#39;s native frame-buffer fetch API for subpass inputs.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_texture_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">sparse</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_binary_ptr_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_ptr_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">register_expression_read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_binary_unord_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_instruction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_glsl_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
<span class="w">                      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_spv_amd_shader_trinary_minmax_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span>
<span class="w">                                               </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_header</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_function_prototype</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">return_flags</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_sampled_image_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">image_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">samp_id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_subgroup_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_texture_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">sparse</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="n">forward</span><span class="p">,</span>
<span class="w">                              </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">inherited_expressions</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_fixup</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">to_struct_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">member_type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">                                 </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qualifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">emit_struct_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">member_type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span>
<span class="w">                            </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qualifier</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_struct_padding_target</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">type_to_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">member</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">type_to_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_block_hints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Allow Metal to use the array&lt;T&gt; template to make arrays a value type</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">type_to_array_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">variable_id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">constant_op_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstantOp</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cop</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">variable_decl_is_remapped_storage</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// GCC workaround of lambdas calling protected functions (for older GCC versions)</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">variable_decl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">image_type_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">member</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">sampler_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">member</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">builtin_to_glsl</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_func_call_arg</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="o">::</span><span class="n">Parameter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">allow_alias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_function_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TextureFunctionNameArguments</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_function_args</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">TextureFunctionArguments</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="o">*</span><span class="n">p_forward</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_initializer_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_zero_initialized_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">unpack_expression_type</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">expr_str</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_type_id</span><span class="p">,</span>
<span class="w">                                       </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_packed</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">row_major</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns true for BuiltInSampleMask because gl_SampleMask[] is an array in SPIR-V, but [[sample_mask]] is a scalar in Metal.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">builtin_translates_to_nonarray</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bitcast_glsl_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argument_type</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emit_complex_bitcast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">skip_argument</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_member_reference</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ptr_chain_is_resolved</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_qualifiers_glsl</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">replace_illegal_names</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">declare_constant_arrays</span><span class="p">();</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">replace_illegal_entry_point_names</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">sync_entry_point_aliases_and_names</span><span class="p">();</span>

<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_reserved_keyword_set</span><span class="p">();</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_illegal_func_names</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Constant arrays of non-primitive types (i.e. matrices) won&#39;t link properly into Metal libraries</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">declare_complex_constant_arrays</span><span class="p">();</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_patch_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_non_native_row_major_matrix</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">member_is_non_native_row_major_matrix</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">convert_row_major_matrix</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">exp_str</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">exp_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_type_id</span><span class="p">,</span>
<span class="w">                                         </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_packed</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">relaxed</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_tesc_shader</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_tese_shader</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">preprocess_op_codes</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">localize_global_variables</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">extract_global_variables_from_functions</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_packable_structs</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_as_packable</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_as_workgroup_struct</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">function_global_vars</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">extract_global_variables_from_function</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">func_id</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">added_arg_ids</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">global_var_ids</span><span class="p">,</span>
<span class="w">                                                </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">processed_func_ids</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">add_interface_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">patch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">add_interface_block_pointer</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ib_var_id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">);</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">InterfaceBlockMeta</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">LocationMeta</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base_type_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_components</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">flat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">noperspective</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">centroid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="kt">bool</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">LocationMeta</span><span class="o">&gt;</span><span class="w"> </span><span class="n">location_meta</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">strip_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">allow_local_declaration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_tesc_invocation_id</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_local_masked_variable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">masked_var</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">strip_array</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_variable_to_interface_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_var_ref</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">InterfaceBlockMeta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_composite_variable_to_interface_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_var_ref</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">InterfaceBlockMeta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_plain_variable_to_interface_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_var_ref</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">InterfaceBlockMeta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">add_component_variable_to_interface_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_var_ref</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                                   </span><span class="n">InterfaceBlockMeta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">meta</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_plain_member_variable_to_interface_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span>
<span class="w">                                                      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_var_ref</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span>
<span class="w">                                                      </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_type</span><span class="p">,</span>
<span class="w">                                                      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="n">InterfaceBlockMeta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">meta</span><span class="p">,</span>
<span class="w">                                                      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mbr_name_qual</span><span class="p">,</span>
<span class="w">                                                      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_chain_qual</span><span class="p">,</span>
<span class="w">                                                      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_mbr_idx</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_composite_member_variable_to_interface_block</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span>
<span class="w">                                                          </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_var_ref</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_type</span><span class="p">,</span>
<span class="w">                                                          </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="n">InterfaceBlockMeta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">meta</span><span class="p">,</span>
<span class="w">                                                          </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mbr_name_qual</span><span class="p">,</span>
<span class="w">                                                          </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_chain_qual</span><span class="p">,</span>
<span class="w">                                                          </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_mbr_idx</span><span class="p">,</span>
<span class="w">                                                          </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">interpolation_qual</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_tess_level_input_to_interface_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_var_ref</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_tess_level_input</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base_ref</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mbr_name</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fix_up_interface_member_indices</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ib_type_id</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_location_as_used_by_shader</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span>
<span class="w">                                         </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">fallback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">ensure_correct_builtin_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">ensure_correct_input_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">component</span><span class="p">,</span>
<span class="w">                                       </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_components</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">strip_array</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_custom_templates</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_custom_functions</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_resources</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_specialization_constants_and_structs</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_interface_block</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ib_var_id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">maybe_emit_array_assignment</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_lhs</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_rhs</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_var_runtime_size_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_resource_array_size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fix_up_shader_inputs_outputs</span><span class="p">();</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">func_type_decl</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">entry_point_args_classic</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">append_comma</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">entry_point_args_argument_buffer</span><span class="p">(</span><span class="kt">bool</span><span class="w"> </span><span class="n">append_comma</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">entry_point_arg_stage_in</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">entry_point_args_builtin</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">entry_point_args_discrete_descriptors</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">append_member_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qualifier</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">ensure_valid_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">pfx</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_sampler_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_swizzle_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_buffer_size_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_sample_rate</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_intersection_query</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_direct_input_builtin</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">builtin_qualifier</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">builtin_type_decl</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">built_in_func_arg</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">prefix_comma</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">member_attribute_qualifier</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">member_location_attribute_qualifier</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">argument_decl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="o">::</span><span class="n">Parameter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">descriptor_address_space</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">plain_address_space</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">round_fp_tex_coords</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">tex_coords</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">coord_is_fp</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_metal_resource_index</span><span class="p">(</span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">basetype</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">plane</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_member_location</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_or_allocate_builtin_input_member_location</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span>
<span class="w">                                                           </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_or_allocate_builtin_output_member_location</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span>
<span class="w">                                                            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">comp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_physical_tess_level_array_size</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// MSL packing rules. These compute the effective packing rules as observed by the MSL compiler in the MSL output.</span>
<span class="w">    </span><span class="c1">// These values can change depending on various extended decorations which control packing rules.</span>
<span class="w">    </span><span class="c1">// We need to make these rules match up with SPIR-V declared rules.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_type_size_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">packed</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">row_major</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_type_array_stride_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">packed</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">row_major</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_type_matrix_stride_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">packed</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">row_major</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_type_alignment_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">packed</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">row_major</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_struct_member_size_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_struct_member_array_stride_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_struct_member_matrix_stride_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_struct_member_alignment_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_input_size_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_input_array_stride_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_input_matrix_stride_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_input_alignment_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_physical_member_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="nf">get_presumed_input_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_declared_struct_size_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">ignore_alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">                                          </span><span class="kt">bool</span><span class="w"> </span><span class="n">ignore_padding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_component_argument</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">align_struct</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">aligned_structs</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_scalar_layout_structs</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_struct_members_packed</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">ensure_member_packing_rules_msl</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ib_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">validate_member_packing_rules_msl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_argument_address_space</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argument</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_type_address_space</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">decoration_flags_signal_volatile</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">to_restrict</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">space</span><span class="p">);</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_stage_in_struct_type</span><span class="p">();</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_stage_out_struct_type</span><span class="p">();</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_patch_stage_in_struct_type</span><span class="p">();</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_patch_stage_out_struct_type</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_tess_factor_struct_name</span><span class="p">();</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_uint_type</span><span class="p">();</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_uint_type_id</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_atomic_func_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mem_order_1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mem_order_2</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_mem_order_2</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">                             </span><span class="kt">bool</span><span class="w"> </span><span class="n">op1_is_pointer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">op1_is_literal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">get_memory_order</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">spv_mem_sem</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_pragma_line</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">line</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_typedef_line</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">line</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_barrier</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_exe_scope</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_mem_scope</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_mem_sem</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emit_array_copy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lhs_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rhs_id</span><span class="p">,</span>
<span class="w">                         </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">lhs_storage</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">rhs_storage</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_implicit_builtins</span><span class="p">();</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">build_constant_uint_array_pointer</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_entry_point_declarations</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">uses_explicit_early_fragment_test</span><span class="p">();</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_frag_coord_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_sample_id_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_sample_mask_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_helper_invocation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_vertex_idx_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_base_vertex_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_instance_idx_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_base_instance_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_view_idx_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_layer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_invocation_id_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_primitive_id_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_subgroup_invocation_id_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_subgroup_size_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_dispatch_base_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_stage_input_size_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_local_invocation_index_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_workgroup_size_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">builtin_frag_depth_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">swizzle_buffer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">buffer_size_buffer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">view_mask_buffer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dynamic_offsets_buffer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">uint_type_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument_buffer_padding_buffer_type_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument_buffer_padding_image_type_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument_buffer_padding_sampler_type_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">does_shader_write_sample_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">frag_shader_needs_discard_checks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">cast_to_variable_store</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">target_id</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr_type</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">cast_from_variable_load</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source_id</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr_type</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_store_statement</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">lhs_expression</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rhs_expression</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_sampled_image_usage</span><span class="p">();</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">access_chain_needs_stage_io_builtin_translation</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">prepare_access_chain_for_scalar_access</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span>
<span class="w">                                                </span><span class="kt">bool</span><span class="w"> </span><span class="o">&amp;</span><span class="n">is_packed</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">fix_up_interpolant_access_chain</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_physical_type_cast</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">*</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">physical_type</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emit_tessellation_access_chain</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emit_tessellation_io_load</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ptr</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_out_of_bounds_tessellation_level</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_lhs</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">ensure_builtin</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_implicit_builtin</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">convert_to_f32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">components</span><span class="p">);</span>

<span class="w">    </span><span class="n">Options</span><span class="w"> </span><span class="n">msl_options</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">SPVFuncImpl</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spv_function_implementations</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Must be ordered to ensure declarations are in a specific order.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">LocationComponentPair</span><span class="p">,</span><span class="w"> </span><span class="n">MSLShaderInterfaceVariable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs_by_location</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">MSLShaderInterfaceVariable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inputs_by_builtin</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">LocationComponentPair</span><span class="p">,</span><span class="w"> </span><span class="n">MSLShaderInterfaceVariable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputs_by_location</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">MSLShaderInterfaceVariable</span><span class="o">&gt;</span><span class="w"> </span><span class="n">outputs_by_builtin</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">location_inputs_in_use</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">location_inputs_in_use_fallback</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">location_outputs_in_use</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">location_outputs_in_use_fallback</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">fragment_output_components</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">builtin_to_automatic_input_location</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">builtin_to_automatic_output_location</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pragma_lines</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">typedef_lines</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">vars_needing_early_declaration</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">StageSetBinding</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">MSLResourceBinding</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">InternalHasher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">resource_bindings</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">StageSetBinding</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">InternalHasher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">resource_arg_buff_idx_to_binding_number</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next_metal_resource_index_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next_metal_resource_index_texture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next_metal_resource_index_sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Intentionally uninitialized, works around MSVC 2013 bug.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next_metal_resource_ids</span><span class="p">[</span><span class="n">kMaxArgumentBuffers</span><span class="p">];</span>

<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">stage_in_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">stage_out_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">patch_stage_in_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">patch_stage_out_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">stage_in_ptr_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">stage_out_ptr_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">tess_level_inner_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">tess_level_outer_var_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">stage_out_masked_builtin_type_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Handle HLSL-style 0-based vertex/instance index.</span>
<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">TriState</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Neutral</span><span class="p">,</span>
<span class="w">        </span><span class="n">No</span><span class="p">,</span>
<span class="w">        </span><span class="n">Yes</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="n">TriState</span><span class="w"> </span><span class="n">needs_base_vertex_arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TriState</span><span class="o">::</span><span class="n">Neutral</span><span class="p">;</span>
<span class="w">    </span><span class="n">TriState</span><span class="w"> </span><span class="n">needs_base_instance_arg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TriState</span><span class="o">::</span><span class="n">Neutral</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_sampled_images</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">builtin_declaration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Handle HLSL-style 0-based vertex/instance index.</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_using_builtin_array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// Force the use of C style array declaration.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">using_builtin_array</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_rasterization_disabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">capture_output_to_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_swizzle_buffer_def</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">used_swizzle_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">added_builtin_tess_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_subgroup_invocation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_subgroup_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_sample_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_helper_invocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">writes_to_depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">qual_pos_var_name</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">stage_in_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;in&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">stage_out_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;out&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">patch_stage_in_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;patchIn&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">patch_stage_out_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;patchOut&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">sampler_name_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Smplr&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">swizzle_name_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Swzl&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">buffer_size_name_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;BufferSize&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">plane_name_suffix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;Plane&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">input_wg_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;gl_in&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">input_buffer_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spvIn&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">output_buffer_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spvOut&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">patch_input_buffer_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spvPatchIn&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">patch_output_buffer_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spvPatchOut&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">tess_factor_buffer_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spvTessLevel&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">index_buffer_var_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;spvIndices&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">previous_instruction_opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">OpNop</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Must be ordered since declaration is in a specific order.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">MSLConstexprSampler</span><span class="o">&gt;</span><span class="w"> </span><span class="n">constexpr_samplers_by_id</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">SetBindingPair</span><span class="p">,</span><span class="w"> </span><span class="n">MSLConstexprSampler</span><span class="p">,</span><span class="w"> </span><span class="n">InternalHasher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">constexpr_samplers_by_binding</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MSLConstexprSampler</span><span class="w"> </span><span class="o">*</span><span class="nf">find_constexpr_sampler</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffers_requiring_array_length</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">buffer_aliases_argument</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer_aliases_discrete</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">atomic_image_vars_emulated</span><span class="p">;</span><span class="w"> </span><span class="c1">// Emulate texture2D atomic operations</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pull_model_inputs</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">recursive_inputs</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">entry_point_bindings</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Must be ordered since array is in a specific order.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">SetBindingPair</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">buffers_requiring_dynamic_offset</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">disabled_frag_outputs</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">SetBindingPair</span><span class="p">,</span><span class="w"> </span><span class="n">InternalHasher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inline_uniform_blocks</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument_buffer_ids</span><span class="p">[</span><span class="n">kMaxArgumentBuffers</span><span class="p">];</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument_buffer_discrete_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument_buffer_device_storage_mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_argument_buffer_aliased_descriptor</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">aliased_var</span><span class="p">,</span>
<span class="w">                                                 </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base_var</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_argument_buffers</span><span class="p">();</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">descriptor_set_is_argument_buffer</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">MSLResourceBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_argument_buffer_resource</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg_idx</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_argument_buffer_padding_buffer_type</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg_buff_index</span><span class="p">,</span><span class="w"> </span><span class="n">MSLResourceBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rez_bind</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_argument_buffer_padding_image_type</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg_buff_index</span><span class="p">,</span><span class="w"> </span><span class="n">MSLResourceBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rez_bind</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_argument_buffer_padding_sampler_type</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg_buff_index</span><span class="p">,</span><span class="w"> </span><span class="n">MSLResourceBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rez_bind</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_argument_buffer_padding_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mbr_type_id</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mbr_idx</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg_buff_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_target_components_for_fragment_location</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">build_extended_vector_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">components</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="n">basetype</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">Unknown</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">build_msl_interpolant_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_noperspective</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">suppress_missing_prototypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">suppress_incompatible_pointer_types_discard_qualifiers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_spv_func_and_recompile</span><span class="p">(</span><span class="n">SPVFuncImpl</span><span class="w"> </span><span class="n">spv_func</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">activate_argument_buffer_resources</span><span class="p">();</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_msl_framebuffer_fetch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_supported_argument_buffer_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">variable_storage_requires_stage_io</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_manual_helper_invocation_updates</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">msl_options</span><span class="p">.</span><span class="n">manual_helper_invocation_updates</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">msl_options</span><span class="p">.</span><span class="n">supports_msl_version</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">needs_frag_discard_checks</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">get_execution_model</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModelFragment</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">msl_options</span><span class="p">.</span><span class="n">supports_msl_version</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">               </span><span class="n">msl_options</span><span class="p">.</span><span class="n">check_discarded_frag_stores</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">frag_shader_needs_discard_checks</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">has_additional_fixed_sample_mask</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">msl_options</span><span class="p">.</span><span class="n">additional_fixed_sample_mask</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mh">0xffffffff</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">additional_fixed_sample_mask_str</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// OpcodeHandler that handles several MSL preprocessing operations.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">OpCodePreprocessor</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">OpCodePreprocessor</span><span class="p">(</span><span class="n">CompilerMSL</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="n">CompilerMSL</span><span class="o">::</span><span class="n">SPVFuncImpl</span><span class="w"> </span><span class="nf">get_spv_func_impl</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">check_resource_write</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">var_id</span><span class="p">);</span>

<span class="w">        </span><span class="n">CompilerMSL</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result_types</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">image_pointers_emulated</span><span class="p">;</span><span class="w"> </span><span class="c1">// Emulate texture2D atomic operations</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">suppress_missing_prototypes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">uses_atomics</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">uses_image_write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">uses_buffer_write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">uses_discard</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_subgroup_invocation_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_subgroup_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_sample_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">needs_helper_invocation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// OpcodeHandler that scans for uses of sampled images</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">SampledImageScanner</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">SampledImageScanner</span><span class="p">(</span><span class="n">CompilerMSL</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">CompilerMSL</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// Sorts the members of a SPIRType and associated Meta info based on a settable sorting</span>
<span class="w">    </span><span class="c1">// aspect, which defines which aspect of the struct members will be used to sort them.</span>
<span class="w">    </span><span class="c1">// Regardless of the sorting aspect, built-in members always appear at the end of the struct.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">MemberSorter</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">enum</span><span class="w"> </span><span class="nc">SortAspect</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">LocationThenBuiltInType</span><span class="p">,</span>
<span class="w">            </span><span class="n">Offset</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">sort</span><span class="p">();</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">operator</span><span class="p">()(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mbr_idx1</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mbr_idx2</span><span class="p">);</span>
<span class="w">        </span><span class="n">MemberSorter</span><span class="p">(</span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">Meta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">SortAspect</span><span class="w"> </span><span class="n">sa</span><span class="p">);</span>

<span class="w">        </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">;</span>
<span class="w">        </span><span class="n">Meta</span><span class="w"> </span><span class="o">&amp;</span><span class="n">meta</span><span class="p">;</span>
<span class="w">        </span><span class="n">SortAspect</span><span class="w"> </span><span class="n">sort_aspect</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace SPIRV_CROSS_NAMESPACE</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 - 2023 Intel Corporation.
This software and the related documents are Intel copyrighted materials, and your
use of them is governed by the express license under which they were provided to
you (License). Unless the License provides otherwise, you may not use, modify, copy,
publish, distribute, disclose or transmit this software or the related documents
without Intel&#39;s prior written permission.
This software and the related documents are provided as is, with no express or implied
warranties, other than those that are expressly stated in the License..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>