<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File spirv_cross.hpp &mdash; Intel® GPA Framework  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/gpa.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
     
    <script type="text/javascript">
        //configure tms    
        var wapLocalCode = 'us_en'; //dynamically set per localized site, see mapping table for values
        var wapSection = "gpa-sdk";
        //load tms
        (function() {
            var host = (window.document.location.protocol == 'http:') ? "http://www.intel.com" : "https://www.intel.com";
            var url = host+"/content/dam/www/global/wap/tms-loader.js"; //wap file url
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;  po.src = url;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
    </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

    <form action="https://software.intel.com/en-us/gpa" method="get" target="_blank">
        <button class="download-button" type="submit">Free Download</button>
    </form>
    

          
          
          <a href="../index.html">
            
              <img src="../_static/logo-classicblue-3000px.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../src/getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#layer-framework-primer">Layer Framework Primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#capture-a-stream">Capture a Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#play-back-stream">Play Back Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#stack-multiple-layers">Stack Multiple Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/guides.html">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/guides/extending_test_layer.html">Extending &quot;Helloworld&quot; Simple Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#layer-anatomy">Layer Anatomy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#api-call-routing">API Call Routing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/reference.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-injector">gpa-injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-player">gpa-player</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-subcapture-recorder">gpa-subcapture-recorder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-info">gpa-stream-info</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-analyzer">gpa-stream-analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-cpp-generator">gpa-cpp-generator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-help">gpa-help</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-metrics-collector">gpa-metrics-collector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-system-info">gpa-system-info</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/layers.html">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#capture">capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#screenshot">screenshot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#hud-layer">hud-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#logging">logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#api-debug-layer">api-debug-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#device-override">device-override</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-resources-layer">dump-resources-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-state-layer">dump-state-layer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/python.html">Python Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html">C++ Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#page-hierarchy">Page Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#class-hierarchy">Class Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#file-hierarchy">File Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#full-api">Full API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#namespaces">Namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#classes-and-structs">Classes and Structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#unions">Unions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#variables">Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#defines">Defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#typedefs">Typedefs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/features.html">Features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#capture-and-playback">Capture and Playback</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#basic-capture-and-playback">Basic Capture and Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#deferred-capture">Deferred Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#range-repeat">Range Repeat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#subcapture">Subcapture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#stream-analysis">Stream Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metric-collection">Metric Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#experiments">Experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metadata-extraction">Metadata Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#resource-extraction">Resource Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-call-inspection">API Call Inspection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#layers">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#heads-up-display-hud-layer">Heads-Up Display(HUD) Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#screenshot-layer">Screenshot Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#logging-layer">Logging Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-debug-layer">Api Debug Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#device-override-layer">Device Override Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#custom-user-layers">Custom (User) Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/requirements.html">System Requirements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#hardware-requirements">Hardware Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#software-requirements">Software Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#supported-graphics-apis">Supported Graphics APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-13-2024">2024.2 (June 13 2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#new">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#changed">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#fixed">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-15-2024">2024.1 (March 15 2024)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id2">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id3">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id4">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#dec-14-2023">2023.4 (Dec 14 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id5">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id6">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id7">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#sept-21-2023">2023.3 (Sept 21 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id8">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id9">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id10">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2023">2023.2 (15 June 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id11">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id12">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id13">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2023">2023.1 (15 March 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id14">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id15">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id16">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2022">2022.4 (15 December 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id17">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id18">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id19">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#deprecated">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2022">2022.3 (15 September 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id20">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id21">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id22">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2022">2022.2 (30 June 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id23">New</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2022">2022.1 (16 March 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id24">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id25">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id26">Changed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2021">2021.4 (16 December 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id27">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id28">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id29">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2021">2021.3 (23 September 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id30">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id31">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id32">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2021">2021.2 (24 June 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id33">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id34">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id35">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2021">2021.1 (24 March 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id36">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id37">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id38">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#january-2021">2020.4.1 (21 January 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id39">NEW</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2020">2020.4 (14 December 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id40">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id41">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id42">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2020">2020.3 (24 September 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id43">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id44">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id45">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2020">2020.2 (25 June 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id46">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id49">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id50">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2020">2020.1 (26 March 2020)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2019">2019.4 (19 December 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2019">2019.3 (26 September 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2019">2019.2 (27 June 2019)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#known-issues-and-limitations">Known Issues and Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id2">2024.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id7">2024.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id12">2023.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id17">2023.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id20">2023.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id23">2023.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id26">2022.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id27">2022.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id28">2022.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id29">2022.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id30">2021.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id31">2021.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id32">2021.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id33">2020.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id34">2019.2</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/licenses.html">Legal Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/licenses.html#third-party-content">Third Party Content</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/disclaimer.html">Notices &amp; Disclaimers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Intel® GPA Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File spirv_cross.hpp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-spirv-cross-hpp">
<span id="program-listing-file-include-spirv-cross-spirv-cross-hpp"></span><h1>Program Listing for File spirv_cross.hpp<a class="headerlink" href="#program-listing-for-file-spirv-cross-hpp" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file_include_spirv_cross_spirv_cross.hpp.html#file-include-spirv-cross-spirv-cross-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">include\spirv_cross\spirv_cross.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright 2015-2021 Arm Limited</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0 OR MIT</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * At your option, you may choose to accept this material under either:</span>
<span class="cm"> *  1. The Apache License, Version 2.0, found at &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;, or</span>
<span class="cm"> *  2. The MIT License, found at &lt;http://opensource.org/licenses/MIT&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef SPIRV_CROSS_HPP</span>
<span class="cp">#define SPIRV_CROSS_HPP</span>

<span class="cp">#ifndef SPV_ENABLE_UTILITY_CODE</span>
<span class="cp">#define SPV_ENABLE_UTILITY_CODE</span>
<span class="cp">#endif</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv_cfg.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv_cross_parsed_ir.hpp&quot;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">SPIRV_CROSS_NAMESPACE</span>
<span class="p">{</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Resource</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Resources are identified with their SPIR-V ID.</span>
<span class="w">    </span><span class="c1">// This is the ID of the OpVariable.</span>
<span class="w">    </span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The type ID of the variable which includes arrays and all type modifications.</span>
<span class="w">    </span><span class="c1">// This type ID is not suitable for parsing OpMemberDecoration of a struct and other decorations in general</span>
<span class="w">    </span><span class="c1">// since these modifications typically happen on the base_type_id.</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">type_id</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The base type of the declared resource.</span>
<span class="w">    </span><span class="c1">// This type is the base type which ignores pointers and arrays of the type_id.</span>
<span class="w">    </span><span class="c1">// This is mostly useful to parse decorations of the underlying type.</span>
<span class="w">    </span><span class="c1">// base_type_id can also be obtained with get_type(get_type(type_id).self).</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">base_type_id</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The declared name (OpName) of the resource.</span>
<span class="w">    </span><span class="c1">// For Buffer blocks, the name actually reflects the externally</span>
<span class="w">    </span><span class="c1">// visible Block name.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// This name can be retrieved again by using either</span>
<span class="w">    </span><span class="c1">// get_name(id) or get_name(base_type_id) depending if it&#39;s a buffer block or not.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// This name can be an empty string in which case get_fallback_name(id) can be</span>
<span class="w">    </span><span class="c1">// used which obtains a suitable fallback identifier for an ID.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">BuiltInResource</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// This is mostly here to support reflection of builtins such as Position/PointSize/CullDistance/ClipDistance.</span>
<span class="w">    </span><span class="c1">// This needs to be different from Resource since we can collect builtins from blocks.</span>
<span class="w">    </span><span class="c1">// A builtin present here does not necessarily mean it&#39;s considered an active builtin,</span>
<span class="w">    </span><span class="c1">// since variable ID &quot;activeness&quot; is only tracked on OpVariable level, not Block members.</span>
<span class="w">    </span><span class="c1">// For that, update_active_builtins() -&gt; has_active_builtin() can be used to further refine the reflection.</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// This is the actual value type of the builtin.</span>
<span class="w">    </span><span class="c1">// Typically float4, float, array&lt;float, N&gt; for the gl_PerVertex builtins.</span>
<span class="w">    </span><span class="c1">// If the builtin is a control point, the control point array type will be stripped away here as appropriate.</span>
<span class="w">    </span><span class="n">TypeID</span><span class="w"> </span><span class="n">value_type_id</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// This refers to the base resource which contains the builtin.</span>
<span class="w">    </span><span class="c1">// If resource is a Block, it can hold multiple builtins, or it might not be a block.</span>
<span class="w">    </span><span class="c1">// For advanced reflection scenarios, all information in builtin/value_type_id can be deduced,</span>
<span class="w">    </span><span class="c1">// it&#39;s just more convenient this way.</span>
<span class="w">    </span><span class="n">Resource</span><span class="w"> </span><span class="n">resource</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">ShaderResources</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">uniform_buffers</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">storage_buffers</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stage_inputs</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stage_outputs</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">subpass_inputs</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">storage_images</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">sampled_images</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">atomic_counters</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">acceleration_structures</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">gl_plain_uniforms</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// There can only be one push constant block,</span>
<span class="w">    </span><span class="c1">// but keep the vector in case this restriction is lifted in the future.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">push_constant_buffers</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">shader_record_buffers</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// For Vulkan GLSL and HLSL source,</span>
<span class="w">    </span><span class="c1">// these correspond to separate texture2D and samplers respectively.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">separate_images</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">separate_samplers</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BuiltInResource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">builtin_inputs</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BuiltInResource</span><span class="o">&gt;</span><span class="w"> </span><span class="n">builtin_outputs</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">CombinedImageSampler</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// The ID of the sampler2D variable.</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">combined_id</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// The ID of the texture2D variable.</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">image_id</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// The ID of the sampler variable.</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="n">sampler_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">SpecializationConstant</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// The ID of the specialization constant.</span>
<span class="w">    </span><span class="n">ConstantID</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// The constant ID of the constant, used in Vulkan during pipeline creation.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">constant_id</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">BufferRange</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">unsigned</span><span class="w"> </span><span class="n">index</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">;</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">range</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">BufferPackingStandard</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">BufferPackingStd140</span><span class="p">,</span>
<span class="w">    </span><span class="n">BufferPackingStd430</span><span class="p">,</span>
<span class="w">    </span><span class="n">BufferPackingStd140EnhancedLayout</span><span class="p">,</span>
<span class="w">    </span><span class="n">BufferPackingStd430EnhancedLayout</span><span class="p">,</span>
<span class="w">    </span><span class="n">BufferPackingHLSLCbuffer</span><span class="p">,</span>
<span class="w">    </span><span class="n">BufferPackingHLSLCbufferPackOffset</span><span class="p">,</span>
<span class="w">    </span><span class="n">BufferPackingScalar</span><span class="p">,</span>
<span class="w">    </span><span class="n">BufferPackingScalarEnhancedLayout</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">EntryPoint</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">execution_model</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Compiler</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">CFG</span><span class="p">;</span>
<span class="w">    </span><span class="k">friend</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">DominatorBuilder</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// The constructor takes a buffer of SPIR-V words and parses it.</span>
<span class="w">    </span><span class="c1">// It will create its own parser, parse the SPIR-V and move the parsed IR</span>
<span class="w">    </span><span class="c1">// as if you had called the constructors taking ParsedIR directly.</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">Compiler</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ir</span><span class="p">);</span>
<span class="w">    </span><span class="n">Compiler</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ir</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">word_count</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// This is more modular. We can also consume a ParsedIR structure directly, either as a move, or copy.</span>
<span class="w">    </span><span class="c1">// With copy, we can reuse the same parsed IR for multiple Compiler instances.</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">Compiler</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ir</span><span class="p">);</span>
<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">Compiler</span><span class="p">(</span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">ir</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">Compiler</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// After parsing, API users can modify the SPIR-V via reflection and call this</span>
<span class="w">    </span><span class="c1">// to disassemble the SPIR-V into the desired langauage.</span>
<span class="w">    </span><span class="c1">// Sub-classes actually implement this.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">compile</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Gets the identifier (OpName) of an ID. If not defined, an empty string will be returned.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_name</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Applies a decoration to an ID. Effectively injects OpDecorate.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_decoration</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_decoration_string</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argument</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Overrides the identifier OpName of an ID.</span>
<span class="w">    </span><span class="c1">// Identifiers beginning with underscores or identifiers which contain double underscores</span>
<span class="w">    </span><span class="c1">// are reserved by the implementation.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_name</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Gets a bitmask for the decorations which are applied to ID.</span>
<span class="w">    </span><span class="c1">// I.e. (1ull &lt;&lt; spv::DecorationFoo) | (1ull &lt;&lt; spv::DecorationBar)</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_decoration_bitset</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns whether the decoration has been applied to the ID.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">has_decoration</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the value for decorations which take arguments.</span>
<span class="w">    </span><span class="c1">// If the decoration is a boolean (i.e. spv::DecorationNonWritable),</span>
<span class="w">    </span><span class="c1">// 1 will be returned.</span>
<span class="w">    </span><span class="c1">// If decoration doesn&#39;t exist or decoration is not recognized,</span>
<span class="w">    </span><span class="c1">// 0 will be returned.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_decoration</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_decoration_string</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Removes the decoration for an ID.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unset_decoration</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V type associated with ID.</span>
<span class="w">    </span><span class="c1">// Mostly used with Resource::type_id and Resource::base_type_id to parse the underlying type of a resource.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_type</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V type of a variable.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_type_from_variable</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the underlying storage class for an OpVariable.</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="nf">get_storage_class</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If get_name() is an empty string, get the fallback name which will be used</span>
<span class="w">    </span><span class="c1">// instead in the disassembled source.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_fallback_name</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// If get_name() of a Block struct is an empty string, get the fallback name.</span>
<span class="w">    </span><span class="c1">// This needs to be per-variable as multiple variables can use the same block type.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_block_fallback_name</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Given an OpTypeStruct in ID, obtain the identifier for member number &quot;index&quot;.</span>
<span class="w">    </span><span class="c1">// This may be an empty string.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_member_name</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Given an OpTypeStruct in ID, obtain the OpMemberDecoration for member number &quot;index&quot;.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_member_decoration</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_member_decoration_string</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sets the member identifier for OpTypeStruct ID, member number &quot;index&quot;.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_member_name</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Returns the qualified member identifier for OpTypeStruct ID, member number &quot;index&quot;,</span>
<span class="w">    </span><span class="c1">// or an empty string if no qualified alias exists</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_member_qualified_name</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the decoration mask for a member of a struct, similar to get_decoration_mask.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_member_decoration_bitset</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns whether the decoration has been applied to a member of a struct.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">has_member_decoration</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Similar to set_decoration, but for struct members.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_member_decoration</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_member_decoration_string</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">,</span>
<span class="w">                                      </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argument</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Unsets a member decoration, similar to unset_decoration.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unset_member_decoration</span><span class="p">(</span><span class="n">TypeID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Gets the fallback name for a member, similar to get_fallback_name.</span>
<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_fallback_member_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">join</span><span class="p">(</span><span class="s">&quot;_&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">index</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Returns a vector of which members of a struct are potentially in use by a</span>
<span class="w">    </span><span class="c1">// SPIR-V shader. The granularity of this analysis is per-member of a struct.</span>
<span class="w">    </span><span class="c1">// This can be used for Buffer (UBO), BufferBlock/StorageBuffer (SSBO) and PushConstant blocks.</span>
<span class="w">    </span><span class="c1">// ID is the Resource::id obtained from get_shader_resources().</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BufferRange</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_active_buffer_ranges</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns the effective size of a buffer block.</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_declared_struct_size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns the effective size of a buffer block, with a given array size</span>
<span class="w">    </span><span class="c1">// for a runtime array.</span>
<span class="w">    </span><span class="c1">// SSBOs are typically declared as runtime arrays. get_declared_struct_size() will return 0 for the size.</span>
<span class="w">    </span><span class="c1">// This is not very helpful for applications which might need to know the array stride of its last member.</span>
<span class="w">    </span><span class="c1">// This can be done through the API, but it is not very intuitive how to accomplish this, so here we provide a helper function</span>
<span class="w">    </span><span class="c1">// to query the size of the buffer, assuming that the last member has a certain size.</span>
<span class="w">    </span><span class="c1">// If the buffer does not contain a runtime array, array_size is ignored, and the function will behave as</span>
<span class="w">    </span><span class="c1">// get_declared_struct_size().</span>
<span class="w">    </span><span class="c1">// To get the array stride of the last member, something like:</span>
<span class="w">    </span><span class="c1">// get_declared_struct_size_runtime_array(type, 1) - get_declared_struct_size_runtime_array(type, 0) will work.</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_declared_struct_size_runtime_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">array_size</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns the effective size of a buffer block struct member.</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="nf">get_declared_struct_member_size</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">struct_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns a set of all global variables which are statically accessed</span>
<span class="w">    </span><span class="c1">// by the control flow graph from the current entry point.</span>
<span class="w">    </span><span class="c1">// Only variables which change the interface for a shader are returned, that is,</span>
<span class="w">    </span><span class="c1">// variables with storage class of Input, Output, Uniform, UniformConstant, PushConstant and AtomicCounter</span>
<span class="w">    </span><span class="c1">// storage classes are returned.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// To use the returned set as the filter for which variables are used during compilation,</span>
<span class="w">    </span><span class="c1">// this set can be moved to set_enabled_interface_variables().</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_active_interface_variables</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sets the interface variables which are used during compilation.</span>
<span class="w">    </span><span class="c1">// By default, all variables are used.</span>
<span class="w">    </span><span class="c1">// Once set, compile() will only consider the set in active_variables.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_enabled_interface_variables</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">active_variables</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Query shader resources, use ids with reflection interface to modify or query binding points, etc.</span>
<span class="w">    </span><span class="n">ShaderResources</span><span class="w"> </span><span class="nf">get_shader_resources</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Query shader resources, but only return the variables which are part of active_variables.</span>
<span class="w">    </span><span class="c1">// E.g.: get_shader_resources(get_active_variables()) to only return the variables which are statically</span>
<span class="w">    </span><span class="c1">// accessed.</span>
<span class="w">    </span><span class="n">ShaderResources</span><span class="w"> </span><span class="nf">get_shader_resources</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">active_variables</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Remapped variables are considered built-in variables and a backend will</span>
<span class="w">    </span><span class="c1">// not emit a declaration for this variable.</span>
<span class="w">    </span><span class="c1">// This is mostly useful for making use of builtins which are dependent on extensions.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_remapped_variable_state</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">remap_enable</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">get_remapped_variable_state</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// For subpassInput variables which are remapped to plain variables,</span>
<span class="w">    </span><span class="c1">// the number of components in the remapped</span>
<span class="w">    </span><span class="c1">// variable must be specified as the backing type of subpass inputs are opaque.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_subpass_input_remapped_components</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">components</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_subpass_input_remapped_components</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// All operations work on the current entry point.</span>
<span class="w">    </span><span class="c1">// Entry points can be swapped out with set_entry_point().</span>
<span class="w">    </span><span class="c1">// Entry points should be set right after the constructor completes as some reflection functions traverse the graph from the entry point.</span>
<span class="w">    </span><span class="c1">// Resource reflection also depends on the entry point.</span>
<span class="w">    </span><span class="c1">// By default, the current entry point is set to the first OpEntryPoint which appears in the SPIR-V module.</span>

<span class="w">    </span><span class="c1">// Some shader languages restrict the names that can be given to entry points, and the</span>
<span class="w">    </span><span class="c1">// corresponding backend will automatically rename an entry point name, during the call</span>
<span class="w">    </span><span class="c1">// to compile() if it is illegal. For example, the common entry point name main() is</span>
<span class="w">    </span><span class="c1">// illegal in MSL, and is renamed to an alternate name by the MSL backend.</span>
<span class="w">    </span><span class="c1">// Given the original entry point name contained in the SPIR-V, this function returns</span>
<span class="w">    </span><span class="c1">// the name, as updated by the backend during the call to compile(). If the name is not</span>
<span class="w">    </span><span class="c1">// illegal, and has not been renamed, or if this function is called before compile(),</span>
<span class="w">    </span><span class="c1">// this function will simply return the same name.</span>

<span class="w">    </span><span class="c1">// New variants of entry point query and reflection.</span>
<span class="w">    </span><span class="c1">// Names for entry points in the SPIR-V module may alias if they belong to different execution models.</span>
<span class="w">    </span><span class="c1">// To disambiguate, we must pass along with the entry point names the execution model.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">EntryPoint</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_entry_points_and_stages</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_entry_point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">execution_model</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Renames an entry point from old_name to new_name.</span>
<span class="w">    </span><span class="c1">// If old_name is currently selected as the current entry point, it will continue to be the current entry point,</span>
<span class="w">    </span><span class="c1">// albeit with a new name.</span>
<span class="w">    </span><span class="c1">// get_entry_points() is essentially invalidated at this point.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">rename_entry_point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">old_name</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_name</span><span class="p">,</span>
<span class="w">                            </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">execution_model</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIREntryPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_entry_point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">execution_model</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIREntryPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_entry_point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">execution_model</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_cleansed_entry_point_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">,</span>
<span class="w">                                                     </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">execution_model</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Traverses all reachable opcodes and sets active_builtins to a bitmask of all builtin variables which are accessed in the shader.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">update_active_builtins</span><span class="p">();</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">has_active_builtin</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Query and modify OpExecutionMode.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_execution_mode_bitset</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unset_execution_mode</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionMode</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_execution_mode</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionMode</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">arg2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Gets argument for an execution mode (LocalSize, Invocations, OutputVertices).</span>
<span class="w">    </span><span class="c1">// For LocalSize or LocalSizeId, the index argument is used to select the dimension (X = 0, Y = 1, Z = 2).</span>
<span class="w">    </span><span class="c1">// For execution modes which do not have arguments, 0 is returned.</span>
<span class="w">    </span><span class="c1">// LocalSizeId query returns an ID. If LocalSizeId execution mode is not used, it returns 0.</span>
<span class="w">    </span><span class="c1">// LocalSize always returns a literal. If execution mode is LocalSizeId,</span>
<span class="w">    </span><span class="c1">// the literal (spec constant or not) is still returned.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_execution_mode_argument</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionMode</span><span class="w"> </span><span class="n">mode</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="nf">get_execution_model</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_tessellation_shader</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_tessellating_triangles</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// In SPIR-V, the compute work group size can be represented by a constant vector, in which case</span>
<span class="w">    </span><span class="c1">// the LocalSize execution mode is ignored.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// This constant vector can be a constant vector, specialization constant vector, or partly specialized constant vector.</span>
<span class="w">    </span><span class="c1">// To modify and query work group dimensions which are specialization constants, SPIRConstant values must be modified</span>
<span class="w">    </span><span class="c1">// directly via get_constant() rather than using LocalSize directly. This function will return which constants should be modified.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// To modify dimensions which are *not* specialization constants, set_execution_mode should be used directly.</span>
<span class="w">    </span><span class="c1">// Arguments to set_execution_mode which are specialization constants are effectively ignored during compilation.</span>
<span class="w">    </span><span class="c1">// NOTE: This is somewhat different from how SPIR-V works. In SPIR-V, the constant vector will completely replace LocalSize,</span>
<span class="w">    </span><span class="c1">// while in this interface, LocalSize is only ignored for specialization constants.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The specialization constant will be written to x, y and z arguments.</span>
<span class="w">    </span><span class="c1">// If the component is not a specialization constant, a zeroed out struct will be written.</span>
<span class="w">    </span><span class="c1">// The return value is the constant ID of the builtin WorkGroupSize, but this is not expected to be useful</span>
<span class="w">    </span><span class="c1">// for most use cases.</span>
<span class="w">    </span><span class="c1">// If LocalSizeId is used, there is no uvec3 value representing the workgroup size, so the return value is 0,</span>
<span class="w">    </span><span class="c1">// but x, y and z are written as normal if the components are specialization constants.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_work_group_size_specialization_constants</span><span class="p">(</span><span class="n">SpecializationConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">SpecializationConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">y</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">SpecializationConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Analyzes all OpImageFetch (texelFetch) opcodes and checks if there are instances where</span>
<span class="w">    </span><span class="c1">// said instruction is used without a combined image sampler.</span>
<span class="w">    </span><span class="c1">// GLSL targets do not support the use of texelFetch without a sampler.</span>
<span class="w">    </span><span class="c1">// To workaround this, we must inject a dummy sampler which can be used to form a sampler2D at the call-site of</span>
<span class="w">    </span><span class="c1">// texelFetch as necessary.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// This must be called before build_combined_image_samplers().</span>
<span class="w">    </span><span class="c1">// build_combined_image_samplers() may refer to the ID returned by this method if the returned ID is non-zero.</span>
<span class="w">    </span><span class="c1">// The return value will be the ID of a sampler object if a dummy sampler is necessary, or 0 if no sampler object</span>
<span class="w">    </span><span class="c1">// is required.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// If the returned ID is non-zero, it can be decorated with set/bindings as desired before calling compile().</span>
<span class="w">    </span><span class="c1">// Calling this function also invalidates get_active_interface_variables(), so this should be called</span>
<span class="w">    </span><span class="c1">// before that function.</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="nf">build_dummy_sampler_for_combined_images</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Analyzes all separate image and samplers used from the currently selected entry point,</span>
<span class="w">    </span><span class="c1">// and re-routes them all to a combined image sampler instead.</span>
<span class="w">    </span><span class="c1">// This is required to &quot;support&quot; separate image samplers in targets which do not natively support</span>
<span class="w">    </span><span class="c1">// this feature, like GLSL/ESSL.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// This must be called before compile() if such remapping is desired.</span>
<span class="w">    </span><span class="c1">// This call will add new sampled images to the SPIR-V,</span>
<span class="w">    </span><span class="c1">// so it will appear in reflection if get_shader_resources() is called after build_combined_image_samplers.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// If any image/sampler remapping was found, no separate image/samplers will appear in the decompiled output,</span>
<span class="w">    </span><span class="c1">// but will still appear in reflection.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// The resulting samplers will be void of any decorations like name, descriptor sets and binding points,</span>
<span class="w">    </span><span class="c1">// so this can be added before compile() if desired.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Combined image samplers originating from this set are always considered active variables.</span>
<span class="w">    </span><span class="c1">// Arrays of separate samplers are not supported, but arrays of separate images are supported.</span>
<span class="w">    </span><span class="c1">// Array of images + sampler -&gt; Array of combined image samplers.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_combined_image_samplers</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Gets a remapping for the combined image samplers.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CombinedImageSampler</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_combined_image_samplers</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">combined_image_samplers</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Set a new variable type remap callback.</span>
<span class="w">    </span><span class="c1">// The type remapping is designed to allow global interface variable to assume more special types.</span>
<span class="w">    </span><span class="c1">// A typical example here is to remap sampler2D into samplerExternalOES, which currently isn&#39;t supported</span>
<span class="w">    </span><span class="c1">// directly by SPIR-V.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// In compile() while emitting code,</span>
<span class="w">    </span><span class="c1">// for every variable that is declared, including function parameters, the callback will be called</span>
<span class="w">    </span><span class="c1">// and the API user has a chance to change the textual representation of the type used to declare the variable.</span>
<span class="w">    </span><span class="c1">// The API user can detect special patterns in names to guide the remapping.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_variable_type_remap_callback</span><span class="p">(</span><span class="n">VariableTypeRemapCallback</span><span class="w"> </span><span class="n">cb</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">variable_remap_callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">cb</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// API for querying which specialization constants exist.</span>
<span class="w">    </span><span class="c1">// To modify a specialization constant before compile(), use get_constant(constant.id),</span>
<span class="w">    </span><span class="c1">// then update constants directly in the SPIRConstant data structure.</span>
<span class="w">    </span><span class="c1">// For composite types, the subconstants can be iterated over and modified.</span>
<span class="w">    </span><span class="c1">// constant_type is the SPIRType for the specialization constant,</span>
<span class="w">    </span><span class="c1">// which can be queried to determine which fields in the unions should be poked at.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SpecializationConstant</span><span class="o">&gt;</span><span class="w"> </span><span class="n">get_specialization_constants</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_constant</span><span class="p">(</span><span class="n">ConstantID</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstant</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_constant</span><span class="p">(</span><span class="n">ConstantID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_current_id_bound</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// API for querying buffer objects.</span>
<span class="w">    </span><span class="c1">// The type passed in here should be the base type of a resource, i.e.</span>
<span class="w">    </span><span class="c1">// get_type(resource.base_type_id)</span>
<span class="w">    </span><span class="c1">// as decorations are set in the basic Block type.</span>
<span class="w">    </span><span class="c1">// The type passed in here must have these decorations set, or an exception is raised.</span>
<span class="w">    </span><span class="c1">// Only UBOs and SSBOs or sub-structs which are part of these buffer types will have these decorations set.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_struct_member_offset</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_struct_member_array_stride</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_struct_member_matrix_stride</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the offset in SPIR-V words (uint32_t) for a decoration which was originally declared in the SPIR-V binary.</span>
<span class="w">    </span><span class="c1">// The offset will point to one or more uint32_t literals which can be modified in-place before using the SPIR-V binary.</span>
<span class="w">    </span><span class="c1">// Note that adding or removing decorations using the reflection API will not change the behavior of this function.</span>
<span class="w">    </span><span class="c1">// If the decoration was declared, sets the word_offset to an offset into the provided SPIR-V binary buffer and returns true,</span>
<span class="w">    </span><span class="c1">// otherwise, returns false.</span>
<span class="w">    </span><span class="c1">// If the decoration does not have any value attached to it (e.g. DecorationRelaxedPrecision), this function will also return false.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">get_binary_offset_for_decoration</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Decoration</span><span class="w"> </span><span class="n">decoration</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">word_offset</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// HLSL counter buffer reflection interface.</span>
<span class="w">    </span><span class="c1">// Append/Consume/Increment/Decrement in HLSL is implemented as two &quot;neighbor&quot; buffer objects where</span>
<span class="w">    </span><span class="c1">// one buffer implements the storage, and a single buffer containing just a lone &quot;int&quot; implements the counter.</span>
<span class="w">    </span><span class="c1">// To SPIR-V these will be exposed as two separate buffers, but glslang HLSL frontend emits a special indentifier</span>
<span class="w">    </span><span class="c1">// which lets us link the two buffers together.</span>

<span class="w">    </span><span class="c1">// Queries if a variable ID is a counter buffer which &quot;belongs&quot; to a regular buffer object.</span>

<span class="w">    </span><span class="c1">// If SPV_GOOGLE_hlsl_functionality1 is used, this can be used even with a stripped SPIR-V module.</span>
<span class="w">    </span><span class="c1">// Otherwise, this query is purely based on OpName identifiers as found in the SPIR-V module, and will</span>
<span class="w">    </span><span class="c1">// only return true if OpSource was reported HLSL.</span>
<span class="w">    </span><span class="c1">// To rely on this functionality, ensure that the SPIR-V module is not stripped.</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">buffer_is_hlsl_counter_buffer</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Queries if a buffer object has a neighbor &quot;counter&quot; buffer.</span>
<span class="w">    </span><span class="c1">// If so, the ID of that counter buffer will be returned in counter_id.</span>
<span class="w">    </span><span class="c1">// If SPV_GOOGLE_hlsl_functionality1 is used, this can be used even with a stripped SPIR-V module.</span>
<span class="w">    </span><span class="c1">// Otherwise, this query is purely based on OpName identifiers as found in the SPIR-V module, and will</span>
<span class="w">    </span><span class="c1">// only return true if OpSource was reported HLSL.</span>
<span class="w">    </span><span class="c1">// To rely on this functionality, ensure that the SPIR-V module is not stripped.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">buffer_get_hlsl_counter_buffer</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">counter_id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the list of all SPIR-V Capabilities which were declared in the SPIR-V module.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">spv</span><span class="o">::</span><span class="n">Capability</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_declared_capabilities</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the list of all SPIR-V extensions which were declared in the SPIR-V module.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_declared_extensions</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// When declaring buffer blocks in GLSL, the name declared in the GLSL source</span>
<span class="w">    </span><span class="c1">// might not be the same as the name declared in the SPIR-V module due to naming conflicts.</span>
<span class="w">    </span><span class="c1">// In this case, SPIRV-Cross needs to find a fallback-name, and it might only</span>
<span class="w">    </span><span class="c1">// be possible to know this name after compiling to GLSL.</span>
<span class="w">    </span><span class="c1">// This is particularly important for HLSL input and UAVs which tends to reuse the same block type</span>
<span class="w">    </span><span class="c1">// for multiple distinct blocks. For these cases it is not possible to modify the name of the type itself</span>
<span class="w">    </span><span class="c1">// because it might be unique. Instead, you can use this interface to check after compilation which</span>
<span class="w">    </span><span class="c1">// name was actually used if your input SPIR-V tends to have this problem.</span>
<span class="w">    </span><span class="c1">// For other names like remapped names for variables, etc, it&#39;s generally enough to query the name of the variables</span>
<span class="w">    </span><span class="c1">// after compiling, block names are an exception to this rule.</span>
<span class="w">    </span><span class="c1">// ID is the name of a variable as returned by Resource::id, and must be a variable with a Block-like type.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// This also applies to HLSL cbuffers.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_remapped_declared_block_name</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// For buffer block variables, get the decorations for that variable.</span>
<span class="w">    </span><span class="c1">// Sometimes, decorations for buffer blocks are found in member decorations instead</span>
<span class="w">    </span><span class="c1">// of direct decorations on the variable itself.</span>
<span class="w">    </span><span class="c1">// The most common use here is to check if a buffer is readonly or writeonly.</span>
<span class="w">    </span><span class="n">Bitset</span><span class="w"> </span><span class="nf">get_buffer_block_flags</span><span class="p">(</span><span class="n">VariableID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns whether the position output is invariant</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_position_invariant</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">position_invariant</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">stream</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// If we&#39;re not going to use any arguments, just return nullptr.</span>
<span class="w">        </span><span class="c1">// We want to avoid case where we return an out of range pointer</span>
<span class="w">        </span><span class="c1">// that trips debug assertions on some platforms.</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">instr</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instr</span><span class="p">.</span><span class="n">is_embedded</span><span class="p">())</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">embedded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span><span class="w"> </span><span class="n">EmbeddedInstruction</span><span class="w"> </span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>
<span class="w">            </span><span class="n">assert</span><span class="p">(</span><span class="n">embedded</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">instr</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">embedded</span><span class="p">.</span><span class="n">ops</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instr</span><span class="p">.</span><span class="n">offset</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">instr</span><span class="p">.</span><span class="n">length</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ir</span><span class="p">.</span><span class="n">spirv</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="w">                </span><span class="n">SPIRV_CROSS_THROW</span><span class="p">(</span><span class="s">&quot;Compiler::stream() out of range.&quot;</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ir</span><span class="p">.</span><span class="n">spirv</span><span class="p">[</span><span class="n">instr</span><span class="p">.</span><span class="n">offset</span><span class="p">];</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">stream_mutable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instr</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*&gt;</span><span class="p">(</span><span class="n">stream</span><span class="p">(</span><span class="n">instr</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">ParsedIR</span><span class="w"> </span><span class="n">ir</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Marks variables which have global scope and variables which can alias with other variables</span>
<span class="w">    </span><span class="c1">// (SSBO, image load store, etc)</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">global_variables</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">aliased_variables</span><span class="p">;</span>

<span class="w">    </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">*</span><span class="n">current_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">*</span><span class="n">current_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">current_loop_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">active_interface_variables</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">check_active_interface_variables</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_loop_level</span><span class="p">();</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_initializers</span><span class="p">(</span><span class="n">SPIRExpression</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">e</span><span class="p">.</span><span class="n">emitted_loop_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current_loop_level</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_initializers</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// If our IDs are out of range here as part of opcodes, throw instead of</span>
<span class="w">    </span><span class="c1">// undefined behavior.</span>
<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="p">,</span><span class="w"> </span><span class="k">typename</span><span class="p">...</span><span class="w"> </span><span class="n">P</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">set</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ir</span><span class="p">.</span><span class="n">add_typed_id</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">),</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">variant_set</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">id</span><span class="p">],</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="w">        </span><span class="n">var</span><span class="p">.</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="w">        </span><span class="n">set_initializers</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">var</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">variant_get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">maybe_get</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">get_type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">variant_get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">id</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">template</span><span class="w"> </span><span class="o">&lt;</span><span class="k">typename</span><span class="w"> </span><span class="nc">T</span><span class="o">&gt;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="n">maybe_get</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">ids</span><span class="p">[</span><span class="n">id</span><span class="p">].</span><span class="n">get_type</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Types</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">))</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Gets the id of SPIR-V type underlying the given type_id, which might be a pointer.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">get_pointee_type_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V type underlying the given type, which might be a pointer.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_pointee_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V type underlying the given type_id, which might be a pointer.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_pointee_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the ID of the SPIR-V type underlying a variable.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_variable_data_type_id</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V type underlying a variable.</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_variable_data_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V type underlying a variable.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_variable_data_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V element type underlying an array variable.</span>
<span class="w">    </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_variable_element_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Gets the SPIR-V element type underlying an array variable.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_variable_element_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sets the qualified member identifier for OpTypeStruct ID, member number &quot;index&quot;.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_member_qualified_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_qualified_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Returns if the given type refers to a sampled image.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_sampled_image_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIREntryPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_entry_point</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIREntryPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_entry_point</span><span class="p">();</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_tessellation_shader</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="p">);</span>

<span class="w">    </span><span class="k">virtual</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">allow_alias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_builtin_variable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_builtin_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_hidden_variable</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">include_builtins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_immutable</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_member_builtin</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="o">*</span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_scalar</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_vector</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_matrix</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_pointer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_physical_pointer</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_physical_pointer_to_buffer_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_runtime_size_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">expression_type_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">expression_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">expression_is_lvalue</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">variable_storage_is_aliased</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">*</span><span class="nf">maybe_get_backing_variable</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">chain</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_read</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">chain</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">forwarded</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_write</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">chain</span><span class="p">);</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_continue</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">block_meta</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ParsedIR</span><span class="o">::</span><span class="n">BLOCK_META_CONTINUE_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_single_block_loop</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get</span><span class="o">&lt;</span><span class="n">SPIRBlock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">merge</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="o">::</span><span class="n">MergeLoop</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">continue_block</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ID</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_break</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">block_meta</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span>
<span class="w">                </span><span class="p">(</span><span class="n">ParsedIR</span><span class="o">::</span><span class="n">BLOCK_META_LOOP_MERGE_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ParsedIR</span><span class="o">::</span><span class="n">BLOCK_META_MULTISELECT_MERGE_BIT</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_loop_break</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">block_meta</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">ParsedIR</span><span class="o">::</span><span class="n">BLOCK_META_LOOP_MERGE_BIT</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kr">inline</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_conditional</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">next</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">ir</span><span class="p">.</span><span class="n">block_meta</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span>
<span class="w">                </span><span class="p">(</span><span class="n">ParsedIR</span><span class="o">::</span><span class="n">BLOCK_META_SELECTION_MERGE_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ParsedIR</span><span class="o">::</span><span class="n">BLOCK_META_MULTISELECT_MERGE_BIT</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Dependency tracking for temporaries read from variables.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_dependees</span><span class="p">(</span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_all_active_variables</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_control_dependent_expressions</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">block</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_all_atomic_capable_variables</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">flush_all_aliased_variables</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_global_read_dependencies</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_global_read_dependencies</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">invalid_expressions</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">update_name_cache</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cache</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// A variant which takes two sets of names. The secondary is only used to verify there are no collisions,</span>
<span class="w">    </span><span class="c1">// but the set is not updated when we have found a new name.</span>
<span class="w">    </span><span class="c1">// Used primarily when adding block interface names.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">update_name_cache</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cache_primary</span><span class="p">,</span>
<span class="w">                           </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cache_secondary</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">function_is_pure</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">block_is_pure</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">execution_is_branchless</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">execution_is_direct_branch</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">execution_is_noop</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">to</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIRBlock</span><span class="o">::</span><span class="n">ContinueBlockType</span><span class="w"> </span><span class="nf">continue_block_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">continue_block</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">force_recompile</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">force_recompile_guarantee_forward_progress</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">clear_force_recompile</span><span class="p">();</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_forcing_recompilation</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_force_recompile</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">is_force_recompile_forward_progress</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">block_is_noop</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">block_is_loop_candidate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="o">::</span><span class="n">Method</span><span class="w"> </span><span class="n">method</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">types_are_logically_equivalent</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">inherit_expression_dependencies</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_implied_read_expression</span><span class="p">(</span><span class="n">SPIRExpression</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_implied_read_expression</span><span class="p">(</span><span class="n">SPIRAccessChain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">source</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_active_interface_variable</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">var_id</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// For proper multiple entry point support, allow querying if an Input or Output</span>
<span class="w">    </span><span class="c1">// variable is part of that entry points interface.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">interface_variable_exists_in_entry_point</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CombinedImageSampler</span><span class="o">&gt;</span><span class="w"> </span><span class="n">combined_image_samplers</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remap_variable_type_name</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var_name</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type_name</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">variable_remap_callback</span><span class="p">)</span>
<span class="w">            </span><span class="n">variable_remap_callback</span><span class="p">(</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">var_name</span><span class="p">,</span><span class="w"> </span><span class="n">type_name</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_ir</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;</span><span class="n">parsed</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_ir</span><span class="p">(</span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">parsed</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">parse_fixup</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Used internally to implement various traversals for queries.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="o">~</span><span class="n">OpcodeHandler</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Return true if traversal should continue.</span>
<span class="w">        </span><span class="c1">// If false, traversal will end immediately.</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle_terminator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">follow_function_call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_current_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Called after returning from a function or when entering a block,</span>
<span class="w">        </span><span class="c1">// can be called multiple times per block,</span>
<span class="w">        </span><span class="c1">// while set_current_block is only called on block entry.</span>
<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">rearm_current_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">begin_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">virtual</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">end_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">BufferAccessHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">BufferAccessHandler</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">,</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BufferRange</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ranges_</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="p">,</span><span class="w"> </span><span class="n">ranges</span><span class="p">(</span><span class="n">ranges_</span><span class="p">)</span>
<span class="w">            </span><span class="p">,</span><span class="w"> </span><span class="n">id</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">BufferRange</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ranges</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">seen</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">InterfaceVariableAccessHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">InterfaceVariableAccessHandler</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variables_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="p">,</span><span class="w"> </span><span class="n">variables</span><span class="p">(</span><span class="n">variables_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variables</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CombinedImageSamplerHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CombinedImageSamplerHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">begin_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">end_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Each function in the call stack needs its own remapping for parameters so we can deduce which global variable each texture/sampler the parameter is statically bound to.</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">parameter_remapping</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">functions</span><span class="p">;</span>

<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">remap_parameter</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">push_remap_parameters</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">pop_remap_parameters</span><span class="p">();</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">register_combined_image_sampler</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">caller</span><span class="p">,</span><span class="w"> </span><span class="n">VariableID</span><span class="w"> </span><span class="n">combined_id</span><span class="p">,</span><span class="w"> </span><span class="n">VariableID</span><span class="w"> </span><span class="n">texture_id</span><span class="p">,</span>
<span class="w">                                             </span><span class="n">VariableID</span><span class="w"> </span><span class="n">sampler_id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">depth</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">DummySamplerForCombinedImageHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">DummySamplerForCombinedImageHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_dummy_sampler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">ActiveBuiltinHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ActiveBuiltinHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">handle_builtin</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">decoration_flags</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_if_builtin</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_if_builtin_or_block</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_if_builtin</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">allow_blocks</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">traverse_all_reachable_opcodes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">OpcodeHandler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">traverse_all_reachable_opcodes</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="n">OpcodeHandler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handler</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// This must be an ordered data structure so we always pick the same type aliases.</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">global_struct_cache</span><span class="p">;</span>

<span class="w">    </span><span class="n">ShaderResources</span><span class="w"> </span><span class="nf">get_shader_resources</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">VariableID</span><span class="o">&gt;</span><span class="w"> </span><span class="o">*</span><span class="n">active_variables</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">VariableTypeRemapCallback</span><span class="w"> </span><span class="n">variable_remap_callback</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">get_common_basic_type</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRType</span><span class="o">::</span><span class="n">BaseType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">base_type</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">forced_temporaries</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">forwarded_temporaries</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">suppressed_usage_tracking</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">hoisted_temporaries</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">forced_invariant_temporaries</span><span class="p">;</span>

<span class="w">    </span><span class="n">Bitset</span><span class="w"> </span><span class="n">active_input_builtins</span><span class="p">;</span>
<span class="w">    </span><span class="n">Bitset</span><span class="w"> </span><span class="n">active_output_builtins</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">clip_distance_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">cull_distance_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">position_invariant</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_parameter_preservation</span><span class="p">(</span>
<span class="w">        </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">entry</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">CFG</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">variable_to_blocks</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">complete_write_blocks</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// If a variable ID or parameter ID is found in this set, a sampler is actually a shadow/comparison sampler.</span>
<span class="w">    </span><span class="c1">// SPIR-V does not support this distinction, so we must keep track of this information outside the type system.</span>
<span class="w">    </span><span class="c1">// There might be unrelated IDs found in this set which do not correspond to actual variables.</span>
<span class="w">    </span><span class="c1">// This set should only be queried for the existence of samplers which are already known to be variables or parameter IDs.</span>
<span class="w">    </span><span class="c1">// Similar is implemented for images, as well as if subpass inputs are needed.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">comparison_ids</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_subpass_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_subpass_input_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// In certain backends, we will need to use a dummy sampler to be able to emit code.</span>
<span class="w">    </span><span class="c1">// GLSL does not support texelFetch on texture2D objects, but SPIR-V does,</span>
<span class="w">    </span><span class="c1">// so we need to workaround by having the application inject a dummy sampler.</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dummy_sampler_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_image_and_sampler_usage</span><span class="p">();</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CombinedImageSamplerDrefHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CombinedImageSamplerDrefHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">dref_combined_samplers</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CombinedImageSamplerUsageHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CombinedImageSamplerUsageHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">,</span>
<span class="w">                                         </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dref_combined_samplers_</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">            </span><span class="p">,</span><span class="w"> </span><span class="n">dref_combined_samplers</span><span class="p">(</span><span class="n">dref_combined_samplers_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">begin_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dref_combined_samplers</span><span class="p">;</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">dependency_hierarchy</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">comparison_ids</span><span class="p">;</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_hierarchy_to_comparison_ids</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ids</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_subpass_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">need_subpass_input_ms</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_dependency</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">src</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">build_function_control_flow_graphs_and_analyze</span><span class="p">();</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CFG</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">function_cfgs</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CFG</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_cfg_for_current_function</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">CFG</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_cfg_for_function</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">CFGBuilder</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">explicit</span><span class="w"> </span><span class="n">CFGBuilder</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">);</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">follow_function_call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">CFG</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">function_cfgs</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">AnalyzeVariableScopeAccessHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">AnalyzeVariableScopeAccessHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">,</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">entry_</span><span class="p">);</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">follow_function_call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_current_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">notify_variable_access</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">block</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">id_is_phi_variable</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">id_is_potential_temporary</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle_terminator</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">entry</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">accessed_variables_to_block</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">accessed_temporaries_to_block</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">result_id_to_type</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">complete_write_variables_to_block</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">partial_write_variables_to_block</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">access_chain_expressions</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// Access chains used in multiple blocks mean hoisting all the variables used to construct the access chain as not all backends can use pointers.</span>
<span class="w">        </span><span class="c1">// This is also relevant when forwarding opaque objects since we cannot lower these to temporaries.</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">rvalue_forward_children</span><span class="p">;</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">*</span><span class="n">current_block</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">StaticExpressionAccessHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">StaticExpressionAccessHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">variable_id_</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">follow_function_call</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">variable_id</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">static_expression</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">write_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PhysicalBlockMeta</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">alignment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">PhysicalStorageBufferPointerHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">explicit</span><span class="w"> </span><span class="n">PhysicalStorageBufferPointerHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">);</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>

<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">non_block_types</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">PhysicalBlockMeta</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_block_type_meta</span><span class="p">;</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">PhysicalBlockMeta</span><span class="w"> </span><span class="o">*&gt;</span><span class="w"> </span><span class="n">access_chain_to_physical_block</span><span class="p">;</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">mark_aligned_access</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>
<span class="w">        </span><span class="n">PhysicalBlockMeta</span><span class="w"> </span><span class="o">*</span><span class="nf">find_block_meta</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_bda_block_entry</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">setup_meta_chain</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">var_id</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_minimum_scalar_alignment</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_non_block_types_from_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_base_non_block_type_id</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type_id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_non_block_pointer_types</span><span class="p">();</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_storage_non_block_pointer_types</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">PhysicalBlockMeta</span><span class="o">&gt;</span><span class="w"> </span><span class="n">physical_storage_type_to_alignment</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_variable_scope</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="n">AnalyzeVariableScopeAccessHandler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handler</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">find_function_local_luts</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">function</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">AnalyzeVariableScopeAccessHandler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handler</span><span class="p">,</span>
<span class="w">                                  </span><span class="kt">bool</span><span class="w"> </span><span class="n">single_function</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">may_read_undefined_variable_in_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">var</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Finds all resources that are written to from inside the critical section, if present.</span>
<span class="w">    </span><span class="c1">// The critical section is delimited by OpBeginInvocationInterlockEXT and</span>
<span class="w">    </span><span class="c1">// OpEndInvocationInterlockEXT instructions. In MSL and HLSL, any resources written</span>
<span class="w">    </span><span class="c1">// while inside the critical section must be placed in a raster order group.</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">InterlockedResourceAccessHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">InterlockedResourceAccessHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">entry_point_id</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">call_stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">entry_point_id</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">begin_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">end_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_crit_sec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interlock_function_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">split_function_case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">control_flow_interlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_critical_section</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">call_stack_is_interlocked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">call_stack</span><span class="p">;</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">access_potential_resource</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">InterlockedResourceAccessPrepassHandler</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">OpcodeHandler</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">InterlockedResourceAccessPrepassHandler</span><span class="p">(</span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler_</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">entry_point_id</span><span class="p">)</span>
<span class="w">            </span><span class="o">:</span><span class="w"> </span><span class="n">compiler</span><span class="p">(</span><span class="n">compiler_</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">call_stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">entry_point_id</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="n">rearm_current_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">handle</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">begin_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="nf">end_function_scope</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">        </span><span class="n">Compiler</span><span class="w"> </span><span class="o">&amp;</span><span class="n">compiler</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">interlock_function_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">current_block_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">split_function_case</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">control_flow_interlock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">call_stack</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_interlocked_resource_usage</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// The set of all resources written while inside the critical section, if present.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">interlocked_resources</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">interlocked_is_complex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">make_constant_null</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">declared_block_names</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">instruction_to_result_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
<span class="w">                                    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">);</span>

<span class="w">    </span><span class="n">Bitset</span><span class="w"> </span><span class="nf">combined_decoration_for_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_desktop_only_format</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ImageFormat</span><span class="w"> </span><span class="n">format</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_depth_image</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_extended_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_extended_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">has_extended_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unset_extended_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_extended_member_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">,</span>
<span class="w">                                        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">get_extended_member_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">has_extended_member_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unset_extended_member_decoration</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="n">ExtendedDecorations</span><span class="w"> </span><span class="n">decoration</span><span class="p">);</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">check_internal_recursion</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">checked_ids</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_contains_recursion</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_array_of_pointers</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_block_like</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_top_level_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">type_is_opaque_value</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">reflection_ssbo_instance_name_is_significant</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_remapped_declared_block_name</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">fallback_prefer_instance_name</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">flush_phi_required</span><span class="p">(</span><span class="n">BlockID</span><span class="w"> </span><span class="n">from</span><span class="p">,</span><span class="w"> </span><span class="n">BlockID</span><span class="w"> </span><span class="n">to</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">evaluate_spec_constant_u32</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRConstantOp</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spec</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">evaluate_constant_u32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_vertex_like_shader</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Get the correct case list for the OpSwitch, since it can be either a</span>
<span class="w">    </span><span class="c1">// 32 bit wide condition or a 64 bit, but the type is not embedded in the</span>
<span class="w">    </span><span class="c1">// instruction itself.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SPIRBlock</span><span class="o">::</span><span class="n">Case</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_case_list</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Used only to implement the old deprecated get_entry_point() interface.</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">SPIREntryPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_first_entry_point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">    </span><span class="n">SPIREntryPoint</span><span class="w"> </span><span class="o">&amp;</span><span class="nf">get_first_entry_point</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">name</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace SPIRV_CROSS_NAMESPACE</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 - 2023 Intel Corporation.
This software and the related documents are Intel copyrighted materials, and your
use of them is governed by the express license under which they were provided to
you (License). Unless the License provides otherwise, you may not use, modify, copy,
publish, distribute, disclose or transmit this software or the related documents
without Intel&#39;s prior written permission.
This software and the related documents are provided as is, with no express or implied
warranties, other than those that are expressly stated in the License..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>