<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Program Listing for File spirv_hlsl.hpp &mdash; Intel® GPA Framework  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/gpa.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists\css\tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/collapsible-lists\js\CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists\js\apply-collapsible-lists.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
     
    <script type="text/javascript">
        //configure tms    
        var wapLocalCode = 'us_en'; //dynamically set per localized site, see mapping table for values
        var wapSection = "gpa-sdk";
        //load tms
        (function() {
            var host = (window.document.location.protocol == 'http:') ? "http://www.intel.com" : "https://www.intel.com";
            var url = host+"/content/dam/www/global/wap/tms-loader.js"; //wap file url
            var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;  po.src = url;
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
        })();
    </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

    <form action="https://software.intel.com/en-us/gpa" method="get" target="_blank">
        <button class="download-button" type="submit">Free Download</button>
    </form>
    

          
          
          <a href="../index.html">
            
              <img src="../_static/logo-classicblue-3000px.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../src/getting_started.html">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#layer-framework-primer">Layer Framework Primer</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#capture-a-stream">Capture a Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#play-back-stream">Play Back Stream</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#stack-multiple-layers">Stack Multiple Layers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/getting_started.html#next-steps">Next Steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/guides.html">Guides</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/guides/extending_test_layer.html">Extending &quot;Helloworld&quot; Simple Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#layer-anatomy">Layer Anatomy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/guides/extending_test_layer.html#api-call-routing">API Call Routing</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/samples.html">Samples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/samples.html#build-samples">Build Samples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#windows">Windows*</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/samples.html#available-samples">Available Samples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#print-api-log">Print API Log</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#helloworld-simple-layer">'Helloworld' Simple Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#helloworld-generated-layer">'Helloworld' Generated Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#range-player">Range Player</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#buffer-extractor">Buffer Extractor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#texture-extraction">Texture Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#sampler-extractor">Sampler Extractor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#shader-extractor">Shader Extractor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#disable-call-in-range">Disable Call in Range</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#metrics-collection">Metrics Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#highlighting-experiment">Highlighting Experiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#pipeline-experiment">Pipeline Experiment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#texture-replacement-experiments">Texture Replacement Experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#advanced-stream-playback">Advanced Stream Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/samples.html#stream-filter">Stream Filter</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/reference.html">Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/utilities.html">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-injector">gpa-injector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-player">gpa-player</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-subcapture-recorder">gpa-subcapture-recorder</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-info">gpa-stream-info</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-stream-analyzer">gpa-stream-analyzer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-cpp-generator">gpa-cpp-generator</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-help">gpa-help</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-metrics-collector">gpa-metrics-collector</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/utilities.html#gpa-system-info">gpa-system-info</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/layers.html">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#capture">capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#screenshot">screenshot</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#hud-layer">hud-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#logging">logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#api-debug-layer">api-debug-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#device-override">device-override</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-resources-layer">dump-resources-layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/layers.html#dump-state-layer">dump-state-layer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/python.html">Python Interface</a></li>
<li class="toctree-l2"><a class="reference internal" href="library_root.html">C++ Interfaces</a><ul>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#page-hierarchy">Page Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#class-hierarchy">Class Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#file-hierarchy">File Hierarchy</a></li>
<li class="toctree-l3"><a class="reference internal" href="library_root.html#full-api">Full API</a><ul>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#namespaces">Namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#classes-and-structs">Classes and Structs</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#enums">Enums</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#unions">Unions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#variables">Variables</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#defines">Defines</a></li>
<li class="toctree-l4"><a class="reference internal" href="library_root.html#typedefs">Typedefs</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/features.html">Features</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#capture-and-playback">Capture and Playback</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#basic-capture-and-playback">Basic Capture and Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#keyframing-capture">Keyframing Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#deferred-capture">Deferred Capture</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#range-repeat">Range Repeat</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#subcapture">Subcapture</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#stream-analysis">Stream Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metric-collection">Metric Collection</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#experiments">Experiments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#metadata-extraction">Metadata Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#resource-extraction">Resource Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-call-inspection">API Call Inspection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/features.html#layers">Layers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#heads-up-display-hud-layer">Heads-Up Display(HUD) Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#screenshot-layer">Screenshot Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#logging-layer">Logging Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#api-debug-layer">Api Debug Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#device-override-layer">Device Override Layer</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/features.html#custom-user-layers">Custom (User) Layers</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/requirements.html">System Requirements</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#hardware-requirements">Hardware Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#software-requirements">Software Requirements</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/requirements.html#supported-graphics-apis">Supported Graphics APIs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/release_notes.html">Release Notes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2023">2023.2 (15 June 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#new">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#changed">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#fixed">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2023">2023.1 (15 March 2023)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id2">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id3">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id4">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2022">2022.4 (15 December 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id5">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id6">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id7">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#deprecated">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2022">2022.3 (15 September 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id8">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id9">Changed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id10">Fixed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2022">2022.2 (30 June 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id11">New</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2022">2022.1 (16 March 2022)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id12">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id13">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id14">Changed</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2021">2021.4 (16 December 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id15">New</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id16">Fixed</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id17">Deprecated</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2021">2021.3 (23 September 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id18">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id19">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id20">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2021">2021.2 (24 June 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id21">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id22">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id23">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2021">2021.1 (24 March 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id24">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id25">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id26">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#january-2021">2020.4.1 (21 January 2021)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id27">NEW</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2020">2020.4 (14 December 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id28">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id29">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id30">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2020">2020.3 (24 September 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id31">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id32">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id33">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2020">2020.2 (25 June 2020)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id34">NEW</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id37">CHANGED</a></li>
<li class="toctree-l3"><a class="reference internal" href="../src/release_notes.html#id38">FIXED</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#march-2020">2020.1 (26 March 2020)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#december-2019">2019.4 (19 December 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#september-2019">2019.3 (26 September 2019)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/release_notes.html#june-2019">2019.2 (27 June 2019)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/troubleshooting.html">Troubleshooting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#known-issues-and-limitations">Known Issues and Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id2">2023.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id7">2023.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id10">2023.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id13">2023.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id16">2022.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id17">2022.3</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id18">2022.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id19">2022.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id20">2021.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id21">2021.2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id22">2021.1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id23">2020.4</a></li>
<li class="toctree-l2"><a class="reference internal" href="../src/troubleshooting.html#id24">2019.2</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/licenses.html">Legal Information</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../src/licenses.html#third-party-content">Third Party Content</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../src/disclaimer.html">Notices &amp; Disclaimers</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Intel® GPA Framework</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Program Listing for File spirv_hlsl.hpp</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="program-listing-for-file-spirv-hlsl-hpp">
<span id="program-listing-file-include-spirv-cross-spirv-hlsl-hpp"></span><h1>Program Listing for File spirv_hlsl.hpp<a class="headerlink" href="#program-listing-for-file-spirv-hlsl-hpp" title="Permalink to this headline"></a></h1>
<p>↰ <a class="reference internal" href="file_include_spirv_cross_spirv_hlsl.hpp.html#file-include-spirv-cross-spirv-hlsl-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">include\spirv_cross\spirv_hlsl.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm"> * Copyright 2016-2021 Robert Konrad</span>
<span class="cm"> * SPDX-License-Identifier: Apache-2.0 OR MIT</span>
<span class="cm"> *</span>
<span class="cm"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="cm"> * you may not use this file except in compliance with the License.</span>
<span class="cm"> * You may obtain a copy of the License at</span>
<span class="cm"> *</span>
<span class="cm"> *     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="cm"> *</span>
<span class="cm"> * Unless required by applicable law or agreed to in writing, software</span>
<span class="cm"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="cm"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="cm"> * See the License for the specific language governing permissions and</span>
<span class="cm"> * limitations under the License.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * At your option, you may choose to accept this material under either:</span>
<span class="cm"> *  1. The Apache License, Version 2.0, found at &lt;http://www.apache.org/licenses/LICENSE-2.0&gt;, or</span>
<span class="cm"> *  2. The MIT License, found at &lt;http://opensource.org/licenses/MIT&gt;.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef SPIRV_HLSL_HPP</span>
<span class="cp">#define SPIRV_HLSL_HPP</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;spirv_glsl.hpp&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;utility&gt;</span>

<span class="k">namespace</span><span class="w"> </span><span class="nn">SPIRV_CROSS_NAMESPACE</span>
<span class="p">{</span>
<span class="c1">// Interface which remaps vertex inputs to a fixed semantic name to make linking easier.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">HLSLVertexAttributeRemap</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">semantic</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// Specifying a root constant (d3d12) or push constant range (vulkan).</span>
<span class="c1">//</span>
<span class="c1">// `start` and `end` denotes the range of the root constant in bytes.</span>
<span class="c1">// Both values need to be multiple of 4.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">RootConstants</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">space</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// For finer control, decorations may be removed from specific resources instead with unset_decoration().</span>
<span class="k">enum</span><span class="w"> </span><span class="nc">HLSLBindingFlagBits</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">HLSL_BINDING_AUTO_NONE_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// Push constant (root constant) resources will be declared as CBVs (b-space) without a register() declaration.</span>
<span class="w">    </span><span class="c1">// A register will be automatically assigned by the D3D compiler, but must therefore be reflected in D3D-land.</span>
<span class="w">    </span><span class="c1">// Push constants do not normally have a DecorationBinding set, but if they do, this can be used to ignore it.</span>
<span class="w">    </span><span class="n">HLSL_BINDING_AUTO_PUSH_CONSTANT_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// cbuffer resources will be declared as CBVs (b-space) without a register() declaration.</span>
<span class="w">    </span><span class="c1">// A register will be automatically assigned, but must be reflected in D3D-land.</span>
<span class="w">    </span><span class="n">HLSL_BINDING_AUTO_CBV_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// All SRVs (t-space) will be declared without a register() declaration.</span>
<span class="w">    </span><span class="n">HLSL_BINDING_AUTO_SRV_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// All UAVs (u-space) will be declared without a register() declaration.</span>
<span class="w">    </span><span class="n">HLSL_BINDING_AUTO_UAV_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// All samplers (s-space) will be declared without a register() declaration.</span>
<span class="w">    </span><span class="n">HLSL_BINDING_AUTO_SAMPLER_BIT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>

<span class="w">    </span><span class="c1">// No resources will be declared with register().</span>
<span class="w">    </span><span class="n">HLSL_BINDING_AUTO_ALL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fffffff</span>
<span class="p">};</span>
<span class="k">using</span><span class="w"> </span><span class="n">HLSLBindingFlags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">uint32_t</span><span class="p">;</span>

<span class="c1">// By matching stage, desc_set and binding for a SPIR-V resource,</span>
<span class="c1">// register bindings are set based on whether the HLSL resource is a</span>
<span class="c1">// CBV, UAV, SRV or Sampler. A single binding in SPIR-V might contain multiple</span>
<span class="c1">// resource types, e.g. COMBINED_IMAGE_SAMPLER, and SRV/Sampler bindings will be used respectively.</span>
<span class="c1">// On SM 5.0 and lower, register_space is ignored.</span>
<span class="c1">//</span>
<span class="c1">// To remap a push constant block which does not have any desc_set/binding associated with it,</span>
<span class="c1">// use ResourceBindingPushConstant{DescriptorSet,Binding} as values for desc_set/binding.</span>
<span class="c1">// For deeper control of push constants, set_root_constant_layouts() can be used instead.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">HLSLResourceBinding</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">stage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModelMax</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Binding</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">register_space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">register_binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">cbv</span><span class="p">,</span><span class="w"> </span><span class="n">uav</span><span class="p">,</span><span class="w"> </span><span class="n">srv</span><span class="p">,</span><span class="w"> </span><span class="n">sampler</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span><span class="w"> </span><span class="nc">HLSLAuxBinding</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">HLSL_AUX_BINDING_BASE_VERTEX_INSTANCE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="p">};</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CompilerHLSL</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">CompilerGLSL</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">Options</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">shader_model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">;</span><span class="w"> </span><span class="c1">// TODO: map ps_4_0_level_9_0,... somehow</span>

<span class="w">        </span><span class="c1">// Allows the PointSize builtin in SM 4.0+, and ignores it, as PointSize is not supported in SM 4+.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">point_size_compat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Allows the PointCoord builtin, returns float2(0.5, 0.5), as PointCoord is not supported in HLSL.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">point_coord_compat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If true, the backend will assume that VertexIndex and InstanceIndex will need to apply</span>
<span class="w">        </span><span class="c1">// a base offset, and you will need to fill in a cbuffer with offsets.</span>
<span class="w">        </span><span class="c1">// Set to false if you know you will never use base instance or base vertex</span>
<span class="w">        </span><span class="c1">// functionality as it might remove an internal cbuffer.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">support_nonzero_base_vertex_base_instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Forces a storage buffer to always be declared as UAV, even if the readonly decoration is used.</span>
<span class="w">        </span><span class="c1">// By default, a readonly storage buffer will be declared as ByteAddressBuffer (SRV) instead.</span>
<span class="w">        </span><span class="c1">// Alternatively, use set_hlsl_force_storage_buffer_as_uav to specify individually.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">force_storage_buffer_as_uav</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Forces any storage image type marked as NonWritable to be considered an SRV instead.</span>
<span class="w">        </span><span class="c1">// For this to work with function call parameters, NonWritable must be considered to be part of the type system</span>
<span class="w">        </span><span class="c1">// so that NonWritable image arguments are also translated to Texture rather than RWTexture.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">nonwritable_uav_texture_as_srv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Enables native 16-bit types. Needs SM 6.2.</span>
<span class="w">        </span><span class="c1">// Uses half/int16_t/uint16_t instead of min16* types.</span>
<span class="w">        </span><span class="c1">// Also adds support for 16-bit load-store from (RW)ByteAddressBuffer.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable_16bit_types</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// If matrices are used as IO variables, flatten the attribute declaration to use</span>
<span class="w">        </span><span class="c1">// TEXCOORD{N,N+1,N+2,...} rather than TEXCOORDN_{0,1,2,3}.</span>
<span class="w">        </span><span class="c1">// If add_vertex_attribute_remap is used and this feature is used,</span>
<span class="w">        </span><span class="c1">// the semantic name will be queried once per active location.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">flatten_matrix_vertex_input_semantics</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Rather than emitting main() for the entry point, use the name in SPIR-V.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">use_entry_point_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Preserve (RW)StructuredBuffer types if the input source was HLSL.</span>
<span class="w">        </span><span class="c1">// This relies on UserTypeGOOGLE to encode the buffer type either as &quot;structuredbuffer&quot; or &quot;rwstructuredbuffer&quot;</span>
<span class="w">        </span><span class="c1">// whereas the type can be extended with an optional subtype, e.g. &quot;structuredbuffer:int&quot;.</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">preserve_structured_buffers</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerHLSL</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">spirv_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">spirv_</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">CompilerHLSL</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ir_</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="n">ir_</span><span class="p">,</span><span class="w"> </span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerHLSL</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ir_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="n">ir_</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">explicit</span><span class="w"> </span><span class="n">CompilerHLSL</span><span class="p">(</span><span class="n">ParsedIR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">ir_</span><span class="p">)</span>
<span class="w">        </span><span class="o">:</span><span class="w"> </span><span class="n">CompilerGLSL</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">ir_</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Options</span><span class="w"> </span><span class="o">&amp;</span><span class="n">get_hlsl_options</span><span class="p">()</span><span class="w"> </span><span class="k">const</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">hlsl_options</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_hlsl_options</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Options</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opts</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">hlsl_options</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opts</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Optionally specify a custom root constant layout.</span>
<span class="w">    </span><span class="c1">//</span>
<span class="w">    </span><span class="c1">// Push constants ranges will be split up according to the</span>
<span class="w">    </span><span class="c1">// layout specified.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">set_root_constant_layouts</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RootConstants</span><span class="o">&gt;</span><span class="w"> </span><span class="n">layout</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Compiles and remaps vertex attributes at specific locations to a fixed semantic.</span>
<span class="w">    </span><span class="c1">// The default is TEXCOORD# where # denotes location.</span>
<span class="w">    </span><span class="c1">// Matrices are unrolled to vectors with notation ${SEMANTIC}_#, where # denotes row.</span>
<span class="w">    </span><span class="c1">// $SEMANTIC is either TEXCOORD# or a semantic name specified here.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_vertex_attribute_remap</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">HLSLVertexAttributeRemap</span><span class="w"> </span><span class="o">&amp;</span><span class="n">vertex_attributes</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">compile</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// This is a special HLSL workaround for the NumWorkGroups builtin.</span>
<span class="w">    </span><span class="c1">// This does not exist in HLSL, so the calling application must create a dummy cbuffer in</span>
<span class="w">    </span><span class="c1">// which the application will store this builtin.</span>
<span class="w">    </span><span class="c1">// The cbuffer layout will be:</span>
<span class="w">    </span><span class="c1">// cbuffer SPIRV_Cross_NumWorkgroups : register(b#, space#) { uint3 SPIRV_Cross_NumWorkgroups_count; };</span>
<span class="w">    </span><span class="c1">// This must be called before compile().</span>
<span class="w">    </span><span class="c1">// The function returns 0 if NumWorkGroups builtin is not statically used in the shader from the current entry point.</span>
<span class="w">    </span><span class="c1">// If non-zero, this returns the variable ID of a cbuffer which corresponds to</span>
<span class="w">    </span><span class="c1">// the cbuffer declared above. By default, no binding or descriptor set decoration is set,</span>
<span class="w">    </span><span class="c1">// so the calling application should declare explicit bindings on this ID before calling compile().</span>
<span class="w">    </span><span class="n">VariableID</span><span class="w"> </span><span class="nf">remap_num_workgroups_builtin</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// Controls how resource bindings are declared in the output HLSL.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_resource_binding_flags</span><span class="p">(</span><span class="n">HLSLBindingFlags</span><span class="w"> </span><span class="n">flags</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// resource is a resource binding to indicate the HLSL CBV, SRV, UAV or sampler binding</span>
<span class="w">    </span><span class="c1">// to use for a particular SPIR-V description set</span>
<span class="w">    </span><span class="c1">// and binding. If resource bindings are provided,</span>
<span class="w">    </span><span class="c1">// is_hlsl_resource_binding_used() will return true after calling ::compile() if</span>
<span class="w">    </span><span class="c1">// the set/binding combination was used by the HLSL code.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">add_hlsl_resource_binding</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">HLSLResourceBinding</span><span class="w"> </span><span class="o">&amp;</span><span class="n">resource</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_hlsl_resource_binding_used</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">model</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Controls which storage buffer bindings will be forced to be declared as UAVs.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_hlsl_force_storage_buffer_as_uav</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">desc_set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// By default, these magic buffers are not assigned a specific binding.</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">set_hlsl_aux_buffer_binding</span><span class="p">(</span><span class="n">HLSLAuxBinding</span><span class="w"> </span><span class="n">binding</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">register_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">register_space</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">unset_hlsl_aux_buffer_binding</span><span class="p">(</span><span class="n">HLSLAuxBinding</span><span class="w"> </span><span class="n">binding</span><span class="p">);</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_hlsl_aux_buffer_binding_used</span><span class="p">(</span><span class="n">HLSLAuxBinding</span><span class="w"> </span><span class="n">binding</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">type_to_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">image_type_hlsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">image_type_hlsl_modern</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">image_type_hlsl_legacy</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_function_prototype</span><span class="p">(</span><span class="n">SPIRFunction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">func</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">return_flags</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_hlsl_entry_point</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_header</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_resources</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_interface_block_globally</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_interface_block_in_struct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">active_locations</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_interface_block_member_in_struct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">member_index</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">,</span>
<span class="w">                                               </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">active_locations</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_builtin_inputs_in_struct</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_builtin_outputs_in_struct</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_builtin_primitive_outputs_in_struct</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_texture_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">sparse</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_instruction</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instruction</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_glsl_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">args</span><span class="p">,</span>
<span class="w">                      </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_buffer_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_push_constant_block</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_uniform</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_modern_uniform</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_legacy_uniform</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_specialization_constants_and_structs</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_composite_constants</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_fixup</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">builtin_to_glsl</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">storage</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">layout_for_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_interpolation_qualifiers</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Bitset</span><span class="w"> </span><span class="o">&amp;</span><span class="n">flags</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">bitcast_glsl_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">argument_type</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">emit_complex_bitcast</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_func_call_arg</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRFunction</span><span class="o">::</span><span class="n">Parameter</span><span class="w"> </span><span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_sampler_expression</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_resource_binding</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_resource_binding_sampler</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_resource_register</span><span class="p">(</span><span class="n">HLSLBindingFlagBits</span><span class="w"> </span><span class="n">flag</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">space</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">binding</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">set</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_initializer_expression</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_sampled_image_op</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">image_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">samp_id</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_access_chain</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instruction</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_load</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instruction</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">read_access_chain</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">*</span><span class="n">expr</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRAccessChain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chain</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">read_access_chain_struct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRAccessChain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chain</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">read_access_chain_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lhs</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SPIRAccessChain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chain</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">write_access_chain</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRAccessChain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chain</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">composite_chain</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">write_access_chain_struct</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRAccessChain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chain</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">,</span>
<span class="w">                                   </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">composite_chain</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">write_access_chain_array</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRAccessChain</span><span class="w"> </span><span class="o">&amp;</span><span class="n">chain</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">,</span>
<span class="w">                                  </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">composite_chain</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">write_access_chain_value</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">composite_chain</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">enclose</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_store</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">instruction</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_atomic</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">Op</span><span class="w"> </span><span class="n">op</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_subgroup_op</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="o">&amp;</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_block_hints</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_struct_member</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">member_type_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="o">&amp;</span><span class="n">qualifier</span><span class="p">,</span>
<span class="w">                            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_rayquery_function</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">commited</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">candidate</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">*</span><span class="n">ops</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_mesh_tasks</span><span class="p">(</span><span class="n">SPIRBlock</span><span class="w"> </span><span class="o">&amp;</span><span class="n">block</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="nf">to_storage_qualifiers_glsl</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRVariable</span><span class="w"> </span><span class="o">&amp;</span><span class="n">var</span><span class="p">)</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">replace_illegal_names</span><span class="p">()</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_hlsl_force_storage_buffer_as_uav</span><span class="p">(</span><span class="n">ID</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">Options</span><span class="w"> </span><span class="n">hlsl_options</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// TODO: Refactor this to be more similar to MSL, maybe have some common system in place?</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_op_fmod</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_fp16_packing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_uint2_packing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_explicit_fp16_packing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_unorm8_packing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_snorm8_packing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_unorm16_packing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_snorm16_packing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_bitfield_insert</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_bitfield_extract</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_inverse_2x2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_inverse_3x3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_inverse_4x4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_scalar_reflect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_scalar_refract</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">requires_scalar_faceforward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">TextureSizeVariants</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// MSVC 2013 workaround.</span>
<span class="w">        </span><span class="n">TextureSizeVariants</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">srv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">unorm</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">uav</span><span class="p">)</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="o">&amp;</span><span class="n">u</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">unorm</span><span class="p">)</span>
<span class="w">                    </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">srv</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">uav</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">required_texture_size_variants</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">require_texture_query_variant</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">var_id</span><span class="p">);</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_texture_size_variants</span><span class="p">(</span><span class="kt">uint64_t</span><span class="w"> </span><span class="n">variant_mask</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">vecsize_qualifier</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">uav</span><span class="p">,</span>
<span class="w">                                    </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">type_qualifier</span><span class="p">);</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">TextureQueryVariantDim</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Query1D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="n">Query1DArray</span><span class="p">,</span>
<span class="w">        </span><span class="n">Query2D</span><span class="p">,</span>
<span class="w">        </span><span class="n">Query2DArray</span><span class="p">,</span>
<span class="w">        </span><span class="n">Query3D</span><span class="p">,</span>
<span class="w">        </span><span class="n">QueryBuffer</span><span class="p">,</span>
<span class="w">        </span><span class="n">QueryCube</span><span class="p">,</span>
<span class="w">        </span><span class="n">QueryCubeArray</span><span class="p">,</span>
<span class="w">        </span><span class="n">Query2DMS</span><span class="p">,</span>
<span class="w">        </span><span class="n">Query2DMSArray</span><span class="p">,</span>
<span class="w">        </span><span class="n">QueryDimCount</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">TextureQueryVariantType</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">QueryTypeFloat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">        </span><span class="n">QueryTypeInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span>
<span class="w">        </span><span class="n">QueryTypeUInt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">,</span>
<span class="w">        </span><span class="n">QueryTypeCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="k">enum</span><span class="w"> </span><span class="nc">BitcastType</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">TypeNormal</span><span class="p">,</span>
<span class="w">        </span><span class="n">TypePackUint2x32</span><span class="p">,</span>
<span class="w">        </span><span class="n">TypeUnpackUint64</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_meshlet_writes</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">analyze_meshlet_writes</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">func_id</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_per_vertex</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id_per_primitive</span><span class="p">,</span>
<span class="w">                                </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">processed_func_ids</span><span class="p">);</span>

<span class="w">    </span><span class="n">BitcastType</span><span class="w"> </span><span class="nf">get_bitcast_type</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">result_type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">op0</span><span class="p">);</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">emit_builtin_variables</span><span class="p">();</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">require_output</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">require_input</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">HLSLVertexAttributeRemap</span><span class="o">&gt;</span><span class="w"> </span><span class="n">remap_vertex_attributes</span><span class="p">;</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="nf">type_to_consumed_locations</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">SPIRType</span><span class="w"> </span><span class="o">&amp;</span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">to_semantic</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">ExecutionModel</span><span class="w"> </span><span class="n">em</span><span class="p">,</span><span class="w"> </span><span class="n">spv</span><span class="o">::</span><span class="n">StorageClass</span><span class="w"> </span><span class="n">sc</span><span class="p">);</span>

<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">num_workgroups_builtin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">HLSLBindingFlags</span><span class="w"> </span><span class="n">resource_binding_flags</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Custom root constant layout, which should be emitted</span>
<span class="w">    </span><span class="c1">// when translating push constant ranges.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RootConstants</span><span class="o">&gt;</span><span class="w"> </span><span class="n">root_constants_layout</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">validate_shader_model</span><span class="p">();</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_unique_identifier</span><span class="p">();</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">unique_identifier_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">StageSetBinding</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">HLSLResourceBinding</span><span class="p">,</span><span class="w"> </span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">InternalHasher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">resource_bindings</span><span class="p">;</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">remap_hlsl_resource_binding</span><span class="p">(</span><span class="n">HLSLBindingFlagBits</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">desc_set</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="o">&amp;</span><span class="n">binding</span><span class="p">);</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">unordered_set</span><span class="o">&lt;</span><span class="n">SetBindingPair</span><span class="p">,</span><span class="w"> </span><span class="n">InternalHasher</span><span class="o">&gt;</span><span class="w"> </span><span class="n">force_uav_buffer_bindings</span><span class="p">;</span>

<span class="w">    </span><span class="k">struct</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">register_index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">register_space</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">explicit_binding</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="kt">bool</span><span class="w"> </span><span class="n">used</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">base_vertex_info</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns true for BuiltInSampleMask because gl_SampleMask[] is an array in SPIR-V, but SV_Coverage is a scalar in HLSL.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">builtin_translates_to_nonarray</span><span class="p">(</span><span class="n">spv</span><span class="o">::</span><span class="n">BuiltIn</span><span class="w"> </span><span class="n">builtin</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Returns true if the specified ID has a UserTypeGOOGLE decoration for StructuredBuffer or RWStructuredBuffer resources.</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">is_user_type_structured</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="k">override</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TypeID</span><span class="o">&gt;</span><span class="w"> </span><span class="n">composite_selection_workaround_types</span><span class="p">;</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="nf">get_inner_entry_point_name</span><span class="p">()</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span><span class="w"> </span><span class="c1">// namespace SPIRV_CROSS_NAMESPACE</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2019 - 2023 Intel Corporation.
This software and the related documents are Intel copyrighted materials, and your
use of them is governed by the express license under which they were provided to
you (License). Unless the License provides otherwise, you may not use, modify, copy,
publish, distribute, disclose or transmit this software or the related documents
without Intel&#39;s prior written permission.
This software and the related documents are provided as is, with no express or implied
warranties, other than those that are expressly stated in the License..</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>