
.. _program_listing_file_include_playback_vulkan-range-repeat-cache-synchronization.h:

Program Listing for File vulkan-range-repeat-cache-synchronization.h
====================================================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_playback_vulkan-range-repeat-cache-synchronization.h>` (``include/playback/vulkan-range-repeat-cache-synchronization.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /******************************************************************************
   Â© Intel Corporation.
    
   This software and the related documents are Intel copyrighted materials,
   and your use of them is governed by the express license under which they
   were provided to you ("License"). Unless the License provides otherwise,
   you may not use, modify, copy, publish, distribute, disclose or transmit
   this software or the related documents without Intel's prior written
   permission.
   
   
    This software and the related documents are provided as is, with no express
   or implied warranties, other than those that are expressly stated in the
   License.
   
   ******************************************************************************/
   
   #pragma once
   
   #include "playback/range-repeat-cache.h"
   #include "playback/vulkan-range-repeat-cache.h"
   
   #include <vector>
   
   #define VK_NO_PROTOTYPES
   #include <vulkan/vulkan.h>
   #undef VK_NO_PROTOTYPES
   
   namespace gpa {
   namespace playback {
   
   class Callable;
   
   namespace repeat {
   namespace vulkan {
   
   // =============================== RangeRepeatCacheVkFence ==============================
   class RangeRepeatCacheVkFence : public RangeRepeatCacheVK
   {
   public:
       typedef std::shared_ptr<RangeRepeatCacheVkFence> Ptr;
       RangeRepeatCacheVkFence(void* object, uint64_t captureKey, playback::Context* context,
                               playback::Callable* callable);
       virtual ~RangeRepeatCacheVkFence();
   
       void OnRangeEnter(GPADispatchTable const*& table) override;
       void OnRangeRepeatRestoreState(GPADispatchTable const*& table, uint64_t repeatPass) override;
       void OnRangeRepeatDestroyObject(GPADispatchTable const*& table, uint64_t repeatPass) override;
       void OnRangeExit(GPADispatchTable const*& table) override;
   
       void SetWaitedOn();
       void SetSignaled();
       void OnReset();
   
   private:
       VkDevice mDevice = VK_NULL_HANDLE;
       VkFence mReplacement = VK_NULL_HANDLE;
       bool mSignaledAtRangeStart = false;
   
       bool mIsWaitedOn = false;  // fence is being waited on as the first operation in the range
       bool mIsSignaled = false;  // fence is signaled and not reset or waited on leter in the range
       bool mIsReset = false;     // fence is reset as first operation in the range
   };
   
   // =============================== RangeRepeatCacheVkSemaphore ==============================
   class RangeRepeatCacheVkSemaphore : public RangeRepeatCacheVK
   {
       enum class SemaphoreState {
           Idle,     // state of the semaphore after creation or after it has been waited on
           Waitable  // state of the semaphore after it was provided to be signaled
       };
   
   public:
       typedef std::shared_ptr<RangeRepeatCacheVkSemaphore> Ptr;
       RangeRepeatCacheVkSemaphore(void* object, uint64_t captureKey, playback::Context* context,
                                   playback::Callable* callable);
       virtual ~RangeRepeatCacheVkSemaphore();
   
       void OnRangeEnter(GPADispatchTable const*& table) override;
       void OnRangeRepeatRecreateObject(GPADispatchTable const*& table, uint64_t repeatPass) override;
       void OnRangeRepeatRestoreState(GPADispatchTable const*& table, uint64_t repeatPass) override;
       void OnRangeRepeatDestroyObject(GPADispatchTable const*& table, uint64_t repeatPass) override;
       void OnRangeExit(GPADispatchTable const*& table) override;
   
       void SetWaitable(VkQueue queue);
       void SetIdle();
   
   private:
       VkDevice mDevice = VK_NULL_HANDLE;
       VkSemaphore mReplacement = VK_NULL_HANDLE;
   
       VkCommandPool mCommandPoolForEmptyCommandBuffer = VK_NULL_HANDLE;
       VkCommandBuffer mEmptyCommandBuffer = VK_NULL_HANDLE;  // dummy command buffer
   
       VkQueue mQueueFromSignalCall = VK_NULL_HANDLE;                  // queue associated with last signalization of the semaphore
       SemaphoreState mState = SemaphoreState::Idle;                   // current state of the semaphore. Updated live during stream playback and repeat cycles
       SemaphoreState mStateAtStartOfTheRange = SemaphoreState::Idle;  // state at start of the range
   };
   // =============================== RangeRepeatCacheVkSemaphore ==============================
   class RangeRepeatCacheVkQueue : public RangeRepeatCacheVK
   {
   public:
       RangeRepeatCacheVkQueue(void* object, uint64_t captureKey, playback::Context* context, playback::Callable* callable);
       virtual ~RangeRepeatCacheVkQueue();
       typedef std::shared_ptr<RangeRepeatCacheVkQueue> Ptr;
   
       void OnQueueSynchronizationRequired(GPADispatchTable const*& table) override;
   };
   
   }  // namespace vulkan
   }  // namespace repeat
   }  // namespace playback
   }  // namespace gpa
